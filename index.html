<!DOCTYPE html>
<html lang="sv">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Projectyle Remake - AI Edition</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: linear-gradient(135deg, #0a0a0a, #1a1a2e);
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            font-family: 'Orbitron', 'Arial', sans-serif;
            color: #00ffff;
            overflow: hidden;
        }
        
        #gameContainer {
            position: relative;
            border: 3px solid #00ffff;
            border-radius: 15px;
            box-shadow: 0 0 30px #00ffff, inset 0 0 20px rgba(0, 255, 255, 0.1);
            overflow: hidden;
            background: linear-gradient(45deg, #0a0a0a, #0f0f23);
        }
        
        #gameCanvas {
            display: block;
            background: radial-gradient(circle at center, #0f0f23 0%, #0a0a0a 100%);
        }
        
        #startMenu {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 100;
        }
        
        #startMenu h1 {
            font-size: 48px;
            margin-bottom: 40px;
            text-shadow: 0 0 20px #00ffff;
        }
        
        .menu-section {
            margin: 20px 0;
            text-align: center;
        }
        
        .menu-section h3 {
            margin-bottom: 15px;
            color: #ffff00;
        }
        
        .menu-buttons {
            display: flex;
            gap: 15px;
            justify-content: center;
            flex-wrap: wrap;
        }
        
        .menu-button {
            padding: 15px 25px;
            background: linear-gradient(135deg, #1a1a2e, #16213e);
            border: 2px solid #00ffff;
            border-radius: 10px;
            color: #00ffff;
            cursor: pointer;
            font-family: inherit;
            font-size: 16px;
            transition: all 0.3s;
        }
        
        .menu-button:hover {
            background: linear-gradient(135deg, #16213e, #1a1a2e);
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.5);
            transform: translateY(-2px);
        }
        
        .menu-button.selected {
            background: linear-gradient(135deg, #004444, #006666);
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.7);
        }
        
        #startButton {
            margin-top: 30px;
            padding: 20px 40px;
            font-size: 24px;
            background: linear-gradient(135deg, #006600, #008800);
            border: 3px solid #00ff00;
            color: #00ff00;
        }
        
        #startButton:hover {
            background: linear-gradient(135deg, #008800, #00aa00);
            box-shadow: 0 0 25px rgba(0, 255, 0, 0.7);
        }
        
        #ui {
            position: absolute;
            top: 15px;
            left: 15px;
            z-index: 10;
            background: linear-gradient(135deg, rgba(0, 0, 0, 0.8), rgba(26, 26, 46, 0.8));
            padding: 15px;
            border-radius: 10px;
        }
        
        #controls {
            position: absolute;
            bottom: 15px;
            left: 15px;
            right: 15px;
            z-index: 10;
            background: linear-gradient(135deg, rgba(0, 0, 0, 0.8), rgba(26, 26, 46, 0.8));
            padding: 15px;
            border-radius: 10px;
            border: 2px solid #00ffff;
            text-align: center;
            font-size: 14px;
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.3);
        }
        
        .score {
            margin: 8px 0;
            font-weight: bold;
            font-size: 16px;
            text-shadow: 0 0 10px currentColor;
        }
        
        .player1 { color: #ff0080; }
        .player2 { color: #80ff00; }
        .player3 { color: #ff8000; }
        
        .ai-indicator {
            font-size: 12px;
            opacity: 0.8;
        }
        
        .room-indicator {
            position: absolute;
            top: 80px;
            left: 15px;
            background: rgba(0, 0, 0, 0.7);
            padding: 8px 12px;
            border-radius: 5px;
            border: 1px solid #00ffff;
            font-size: 12px;
        }
        
        .active-player {
            position: absolute;
            top: 120px;
            left: 15px;
            background: rgba(0, 0, 0, 0.7);
            padding: 8px 12px;
            border-radius: 5px;
            border: 1px solid #ffff00;
            font-size: 12px;
            color: #ffff00;
        }
        
        .powerup-display {
            font-size: 16px;
            font-weight: bold;
            opacity: 1;
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="gameCanvas" width="1600" height="1200"></canvas>
        
        <div id="startMenu">
            <h1>ðŸŽ® PROJECTYLE</h1>
            
            <div class="menu-section">
                <h3>Antal MÃ¤nskliga Spelare</h3>
                <div class="menu-buttons">
                    <button class="menu-button selected" data-humans="1">1 Spelare</button>
                    <button class="menu-button" data-humans="2">2 Spelare</button>
                    <button class="menu-button" data-humans="3">3 Spelare</button>
                </div>
            </div>
            
            <div class="menu-section">
                <h3>AI Intelligens</h3>
                <div class="menu-buttons">
                    <button class="menu-button" data-difficulty="easy">Dum (fÃ¶ljer bara bollen)</button>
                    <button class="menu-button selected" data-difficulty="medium">Smart (grundstrategi)</button>
                    <button class="menu-button" data-difficulty="hard">Genial (fÃ¶rutsÃ¤ger & taktik)</button>
                </div>
            </div>
            
            <button id="startButton" class="menu-button">STARTA SPEL</button>
            
            <div class="menu-section" style="margin-top: 40px;">
                <h3>Kontroller</h3>
                <div style="text-align: left; max-width: 600px; margin: 0 auto; font-size: 14px; color: #00ffff;">
                    <div style="margin: 10px 0;">
                        <span style="color: #ff0080;">ðŸ”´ Spelare 1:</span> Piltangenter fÃ¶r rÃ¶relse + Mellanslag fÃ¶r spark
                    </div>
                    <div style="margin: 10px 0;">
                        <span style="color: #80ff00;">ðŸŸ¢ Spelare 2:</span> WASD fÃ¶r rÃ¶relse + VÃ¤nster Shift fÃ¶r spark
                    </div>
                    <div style="margin: 10px 0;">
                        <span style="color: #ff8000;">ðŸŸ  Spelare 3:</span> IJKL fÃ¶r rÃ¶relse + H fÃ¶r spark
                    </div>
                    <div style="margin-top: 20px; color: #ffff00;">
                        âš¡ <strong>Tips:</strong> StÃ¥ nÃ¤ra bollen och sparka fÃ¶r extra kraft!<br>
                        ðŸŽ¯ <strong>MÃ¥l:</strong> GÃ¶ra mÃ¥l i motstÃ¥ndarnas mÃ¥l!<br>
                        ðŸŒ€ <strong>Portaler:</strong> AnvÃ¤nd portalerna fÃ¶r att fÃ¶rflytta dig mellan rum!
                    </div>
                    <div style="margin-top: 20px; opacity: 0.7;">
                        R = Starta om | ESC = Paus | M = Tillbaka till meny
                    </div>
                </div>
            </div>
        </div>
        
        <div id="ui">
            <div class="score player1">
                ðŸ”´ Spelare 1: <span id="score1">0</span> <span id="ai1" class="ai-indicator"></span> <span id="powerup1" class="powerup-display"></span>
            </div>
            <div class="score player2">
                ðŸŸ¢ Spelare 2: <span id="score2">0</span> <span id="ai2" class="ai-indicator"></span> <span id="powerup2" class="powerup-display"></span>
            </div>
            <div class="score player3">
                ðŸŸ  Spelare 3: <span id="score3">0</span> <span id="ai3" class="ai-indicator"></span> <span id="powerup3" class="powerup-display"></span>
            </div>
        </div>
        <div class="room-indicator">
            Aktuellt rum: <span id="currentRoom">Center</span>
        </div>
        <div class="active-player">
            Rum: <span id="activePlayers">Center</span><br>
            Boll: <span id="puckPosition">0,0</span>
        </div>
        <div id="controls">
            <strong>ðŸŽ® PROJECTYLE</strong> | 
            AI: <span id="difficultyDisplay">Smart</span> | 
            <em style="opacity: 0.7;">R = Restart | ESC = Paus | M = Meny</em>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        // Game Configuration
        const CONFIG = {
            // Room settings
            ROOM_SIZE: 1000,
            ROOM_SPACING: 1.5,
            CORNER_RADIUS: 50,
            
            // Object sizes
            PUCK_RADIUS: 10,
            PADDLE_RADIUS: 25,
            GOAL_SIZE: 100,
            TUNNEL_WIDTH: 60,
            
            // Physics settings
            PLAYER_SPEED: 6.75,  // 50% faster than original 4.5
            MAX_PUCK_SPEED: 12,   // Increased top speed
            FRICTION: 0.99,
            WALL_BOUNCE: 0.77,   // 10% more bounce than original 0.7
            KICK_RANGE: 50,
            KICK_FORCE: 10.5,    // 50% more powerful kicks
            
            // Visual settings
            TRAIL_LENGTH: 8,
            BOUNCE_EFFECT_DURATION: 15,
            PORTAL_TRANSITION_DURATION: 400,
            PORTAL_COOLDOWN: 60,
            PORTAL_PUSH_DISTANCE: 80,
            
            // AI settings
            STUCK_THRESHOLD: 30,
            STUCK_RESET: 60,
            ANTI_STUCK_FORCE: 2,
            
            // Power-up settings
            POWERUP_SPAWN_CHANCE: 0.0008,  // Reduced chance per frame (about every 20-25 seconds)
            POWERUP_SIZE: 20,
            POWERUP_LIFETIME: 600,     // 10 seconds before disappearing
            POWERUP_DURATION: {
                magnet: 300,      // 5 seconds
                speed: 300,       // 5 seconds
                slowdown: 300,    // 5 seconds
                shield: 300       // 5 seconds
            }
        };
        
        // Keep old constants for backwards compatibility
        const ROOM_SIZE = CONFIG.ROOM_SIZE;
        const PUCK_RADIUS = CONFIG.PUCK_RADIUS;
        const PADDLE_RADIUS = CONFIG.PADDLE_RADIUS;
        const GOAL_SIZE = CONFIG.GOAL_SIZE;
        const TUNNEL_WIDTH = CONFIG.TUNNEL_WIDTH;
        const MAX_SPEED = CONFIG.MAX_PUCK_SPEED;
        const FRICTION = CONFIG.FRICTION;
        const KICK_RANGE = CONFIG.KICK_RANGE;
        const KICK_FORCE = CONFIG.KICK_FORCE;
        
        // Game configuration
        let gameConfig = {
            humanPlayers: 1,
            aiPlayers: 2,
            aiDifficulty: 'medium',
            gameStarted: false
        };
        
        // AI difficulty settings - now focused on intelligence, not speed
        const aiSettings = {
            easy: {
                reactionTime: 25,        // Slower decision making
                accuracy: 0.4,           // Poor aim
                strategy: 0.2,           // Mostly just follows ball
                predictionFrames: 0      // No prediction
            },
            medium: {
                reactionTime: 15,        // Normal decision making
                accuracy: 0.7,           // Decent aim
                strategy: 0.6,           // Some strategic thinking
                predictionFrames: 3      // Short prediction
            },
            hard: {
                reactionTime: 8,         // Quick decision making  
                accuracy: 0.9,           // Excellent aim
                strategy: 0.85,          // Very strategic
                predictionFrames: 6      // Good prediction
            }
        };
        
        // Game state with AI support
        let gameState = {
            camera: { x: 0, y: 0 },
            puck: { 
                x: 0, y: 0, vx: 0, vy: 0, 
                trail: [], 
                currentRoom: 'center',
                lastRoom: 'center'
            },
            playerCharacters: {
                1: {
                    center: { x: -100, y: -100, active: false, vx: 0, vy: 0 },
                    player1_zone: { x: 0, y: -ROOM_SIZE * 1.5 - 100, active: false, vx: 0, vy: 0 },
                    player2_zone: { x: ROOM_SIZE * 1.5 + 100, y: -100, active: false, vx: 0, vy: 0 },
                    player3_zone: { x: -ROOM_SIZE * 1.5 - 100, y: -100, active: false, vx: 0, vy: 0 },
                    frantic_zone: { x: -100, y: ROOM_SIZE * 1.5 + 100, active: false, vx: 0, vy: 0 }
                },
                2: {
                    center: { x: 0, y: 0, active: false, vx: 0, vy: 0 },
                    player1_zone: { x: 0, y: -ROOM_SIZE * 1.5, active: false, vx: 0, vy: 0 },
                    player2_zone: { x: ROOM_SIZE * 1.5, y: 0, active: false, vx: 0, vy: 0 },
                    player3_zone: { x: -ROOM_SIZE * 1.5, y: 0, active: false, vx: 0, vy: 0 },
                    frantic_zone: { x: 0, y: ROOM_SIZE * 1.5, active: false, vx: 0, vy: 0 }
                },
                3: {
                    center: { x: 100, y: 100, active: false, vx: 0, vy: 0 },
                    player1_zone: { x: 100, y: -ROOM_SIZE * 1.5 + 100, active: false, vx: 0, vy: 0 },
                    player2_zone: { x: ROOM_SIZE * 1.5 - 100, y: 100, active: false, vx: 0, vy: 0 },
                    player3_zone: { x: -ROOM_SIZE * 1.5 + 100, y: 100, active: false, vx: 0, vy: 0 },
                    frantic_zone: { x: 100, y: ROOM_SIZE * 1.5 - 100, active: false, vx: 0, vy: 0 }
                }
            },
            playerColors: {
                1: '#ff0080',
                2: '#80ff00', 
                3: '#ff8000'
            },
            playerScores: { 1: 0, 2: 0, 3: 0 },
            playerTypes: { 1: 'human', 2: 'ai', 3: 'ai' }, // 'human' or 'ai'
            aiState: {
                1: { target: { x: 0, y: 0 }, lastDecision: 0, strategy: 'follow', stuckCounter: 0, lastPos: { x: 0, y: 0 } },
                2: { target: { x: 0, y: 0 }, lastDecision: 0, strategy: 'follow', stuckCounter: 0, lastPos: { x: 0, y: 0 } },
                3: { target: { x: 0, y: 0 }, lastDecision: 0, strategy: 'follow', stuckCounter: 0, lastPos: { x: 0, y: 0 } }
            },
            keys: {},
            kickCooldowns: { 1: 0, 2: 0, 3: 0 }, // Prevent spam-kicking
            bounceEffects: [], // Visual effects for wall bounces
            currentRoom: 'center',
            gameTime: 0,
            isPaused: false,
            portalTransition: {
                active: false,
                startTime: 0,
                duration: 400, // 0.4 seconds
                fromRoom: null,
                toRoom: null,
                fromPos: { x: 0, y: 0 },
                toPos: { x: 0, y: 0 },
                cooldown: 0 // Prevents immediate re-entry
            },
            powerUps: {
                spawned: [],  // Active power-ups on the field
                playerEffects: {
                    1: { magnet: 0, speed: 0, shield: 0, slowdown: 0 },
                    2: { magnet: 0, speed: 0, shield: 0, slowdown: 0 },
                    3: { magnet: 0, speed: 0, shield: 0, slowdown: 0 }
                },
                globalEffects: { slowdown: 0 }  // Affects all players
            }
        };
        
        // Room definitions - rooms are now spaced further apart
        const ROOM_SPACING = CONFIG.ROOM_SPACING;
        const rooms = {
            center: { 
                x: 0, y: 0, 
                width: ROOM_SIZE, height: ROOM_SIZE,
                connections: {
                    player1_zone: { x: 0, y: -ROOM_SIZE/2, width: TUNNEL_WIDTH, height: TUNNEL_WIDTH },
                    player2_zone: { x: ROOM_SIZE/2, y: 0, width: TUNNEL_WIDTH, height: TUNNEL_WIDTH },
                    player3_zone: { x: -ROOM_SIZE/2, y: 0, width: TUNNEL_WIDTH, height: TUNNEL_WIDTH },
                    frantic_zone: { x: 0, y: ROOM_SIZE/2, width: TUNNEL_WIDTH, height: TUNNEL_WIDTH }
                },
                color: '#00ff44',
                type: 'center'
            },
            player1_zone: { 
                x: 0, y: -ROOM_SIZE * ROOM_SPACING, 
                width: ROOM_SIZE, height: ROOM_SIZE,
                connections: {
                    center: { x: 0, y: ROOM_SIZE/2, width: TUNNEL_WIDTH, height: TUNNEL_WIDTH }
                },
                color: '#44ff44',
                type: 'defensive',
                owner: 1,
                goalColor: '#ff0080',
                goals: [{ x: 0, y: -ROOM_SIZE/2 + 2, direction: 'top', owner: 1 }]
            },
            player2_zone: { 
                x: ROOM_SIZE * ROOM_SPACING, y: 0, 
                width: ROOM_SIZE, height: ROOM_SIZE,
                connections: {
                    center: { x: -ROOM_SIZE/2, y: 0, width: TUNNEL_WIDTH, height: TUNNEL_WIDTH }
                },
                color: '#00ff00',
                type: 'defensive',
                owner: 2,
                goalColor: '#80ff00',
                goals: [{ x: ROOM_SIZE/2 - 2, y: 0, direction: 'right', owner: 2 }]
            },
            player3_zone: { 
                x: -ROOM_SIZE * ROOM_SPACING, y: 0, 
                width: ROOM_SIZE, height: ROOM_SIZE,
                connections: {
                    center: { x: ROOM_SIZE/2, y: 0, width: TUNNEL_WIDTH, height: TUNNEL_WIDTH }
                },
                color: '#44ff00',
                type: 'defensive',
                owner: 3,
                goalColor: '#ff8000',
                goals: [{ x: -ROOM_SIZE/2 + 2, y: 0, direction: 'left', owner: 3 }]
            },
            frantic_zone: { 
                x: 0, y: ROOM_SIZE * ROOM_SPACING, 
                width: ROOM_SIZE, height: ROOM_SIZE,
                connections: {
                    center: { x: 0, y: -ROOM_SIZE/2, width: TUNNEL_WIDTH, height: TUNNEL_WIDTH }
                },
                color: '#22ff22',
                type: 'frantic',
                goals: [
                    { x: -ROOM_SIZE/2, y: 0, direction: 'left', owner: 1 },
                    { x: ROOM_SIZE/2, y: 0, direction: 'right', owner: 2 },
                    { x: 0, y: ROOM_SIZE/2 - 2, direction: 'bottom', owner: 3 }
                ]
            }
        };
        
        // Menu system
        function initMenu() {
            const humanButtons = document.querySelectorAll('[data-humans]');
            const difficultyButtons = document.querySelectorAll('[data-difficulty]');
            const startButton = document.getElementById('startButton');
            
            humanButtons.forEach(btn => {
                btn.addEventListener('click', () => {
                    humanButtons.forEach(b => b.classList.remove('selected'));
                    btn.classList.add('selected');
                    gameConfig.humanPlayers = parseInt(btn.dataset.humans);
                    gameConfig.aiPlayers = 3 - gameConfig.humanPlayers;
                    updatePlayerTypes();
                });
            });
            
            difficultyButtons.forEach(btn => {
                btn.addEventListener('click', () => {
                    difficultyButtons.forEach(b => b.classList.remove('selected'));
                    btn.classList.add('selected');
                    gameConfig.aiDifficulty = btn.dataset.difficulty;
                    const displayNames = { easy: 'Dum', medium: 'Smart', hard: 'Genial' };
                    document.getElementById('difficultyDisplay').textContent = displayNames[gameConfig.aiDifficulty];
                });
            });
            
            startButton.addEventListener('click', startGame);
        }
        
        function updatePlayerTypes() {
            for (let i = 1; i <= 3; i++) {
                gameState.playerTypes[i] = i <= gameConfig.humanPlayers ? 'human' : 'ai';
                const aiIndicator = document.getElementById(`ai${i}`);
                aiIndicator.textContent = gameState.playerTypes[i] === 'ai' ? '(AI)' : '';
            }
        }
        
        function startGame() {
            gameConfig.gameStarted = true;
            document.getElementById('startMenu').style.display = 'none';
            updatePlayerTypes();
            init();
        }
        
        function showMenu() {
            gameConfig.gameStarted = false;
            document.getElementById('startMenu').style.display = 'flex';
        }
        
        // Bounce effect system
        function createBounceEffect(x, y) {
            gameState.bounceEffects.push({
                x: x,
                y: y,
                life: 15, // frames to live
                maxLife: 15,
                size: 20
            });
        }
        
        function updateBounceEffects() {
            for (let i = gameState.bounceEffects.length - 1; i >= 0; i--) {
                const effect = gameState.bounceEffects[i];
                effect.life--;
                
                if (effect.life <= 0) {
                    gameState.bounceEffects.splice(i, 1);
                }
            }
        }
        
        // Power-up system
        function spawnPowerUp() {
            if (Math.random() < CONFIG.POWERUP_SPAWN_CHANCE && gameState.powerUps.spawned.length < 3) {
                const types = ['magnet', 'speed', 'slowdown', 'shield'];
                const type = types[Math.floor(Math.random() * types.length)];
                const room = rooms[gameState.currentRoom];
                
                // Spawn in a random position within the current room
                const x = room.x + (Math.random() - 0.5) * (room.width - 100);
                const y = room.y + (Math.random() - 0.5) * (room.height - 100);
                
                gameState.powerUps.spawned.push({
                    type: type,
                    x: x,
                    y: y,
                    room: gameState.currentRoom,
                    rotation: 0,
                    pulsePhase: 0,
                    lifetime: CONFIG.POWERUP_LIFETIME
                });
            }
        }
        
        function updatePowerUps() {
            // Update spawned power-ups and remove expired ones
            for (let i = gameState.powerUps.spawned.length - 1; i >= 0; i--) {
                const powerUp = gameState.powerUps.spawned[i];
                powerUp.rotation += 0.02;
                powerUp.pulsePhase += 0.1;
                powerUp.lifetime--;
                
                // Remove if expired
                if (powerUp.lifetime <= 0) {
                    gameState.powerUps.spawned.splice(i, 1);
                }
            }
            
            // Check for power-up collection
            for (let playerId = 1; playerId <= 3; playerId++) {
                const character = getActiveCharacter(playerId);
                if (!character) continue;
                
                for (let i = gameState.powerUps.spawned.length - 1; i >= 0; i--) {
                    const powerUp = gameState.powerUps.spawned[i];
                    if (powerUp.room === gameState.currentRoom && 
                        distance(character, powerUp) < PADDLE_RADIUS + CONFIG.POWERUP_SIZE) {
                        
                        // Collect power-up
                        applyPowerUp(playerId, powerUp.type);
                        gameState.powerUps.spawned.splice(i, 1);
                    }
                }
            }
            
            // Update active effects durations
            for (let playerId = 1; playerId <= 3; playerId++) {
                const effects = gameState.powerUps.playerEffects[playerId];
                for (let effect in effects) {
                    if (effects[effect] > 0) {
                        effects[effect]--;
                    }
                }
            }
            
            // Global effects no longer needed - slowdown is now per-player
        }
        
        function applyPowerUp(playerId, type) {
            switch (type) {
                case 'magnet':
                case 'speed':
                case 'shield':
                    gameState.powerUps.playerEffects[playerId][type] = CONFIG.POWERUP_DURATION[type];
                    break;
                case 'slowdown':
                    // Slowdown affects opponents, not the player who picks it up
                    for (let i = 1; i <= 3; i++) {
                        if (i !== playerId) {
                            gameState.powerUps.playerEffects[i].slowdown = CONFIG.POWERUP_DURATION.slowdown;
                        }
                    }
                    break;
            }
        }
        
        function drawBounceEffects() {
            gameState.bounceEffects.forEach(effect => {
                const alpha = effect.life / effect.maxLife;
                const currentSize = effect.size * (1 - alpha * 0.5); // Shrink over time
                
                // Save context to avoid affecting other drawings
                ctx.save();
                
                ctx.globalAlpha = alpha * 0.8;
                ctx.strokeStyle = '#ffff00';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.arc(effect.x, effect.y, currentSize, 0, Math.PI * 2);
                ctx.stroke();
                
                // Inner ring
                ctx.strokeStyle = '#ffffff';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.arc(effect.x, effect.y, currentSize * 0.6, 0, Math.PI * 2);
                ctx.stroke();
                
                // Restore context
                ctx.restore();
            });
        }
        function tryKick(playerId) {
            // Check cooldown
            if (gameState.kickCooldowns[playerId] > 0) return false;
            
            const activeCharacter = getActiveCharacter(playerId);
            if (!activeCharacter) return false;
            
            // Check if close enough to puck
            const dist = distance(activeCharacter, gameState.puck);
            if (dist > KICK_RANGE) return false;
            
            // Calculate kick direction (away from player)
            const dx = gameState.puck.x - activeCharacter.x;
            const dy = gameState.puck.y - activeCharacter.y;
            const kickDist = Math.sqrt(dx * dx + dy * dy);
            
            if (kickDist < 5) return false; // Too close, no direction
            
            // Calculate player's speed for variable kick strength
            let playerSpeed = 0;
            if (activeCharacter.momentum) {
                playerSpeed = Math.sqrt(activeCharacter.momentum.x * activeCharacter.momentum.x + 
                                      activeCharacter.momentum.y * activeCharacter.momentum.y);
            } else if (activeCharacter.vx !== undefined && activeCharacter.vy !== undefined) {
                // For AI players who don't use momentum system
                playerSpeed = Math.sqrt(activeCharacter.vx * activeCharacter.vx + 
                                      activeCharacter.vy * activeCharacter.vy);
            }
            
            // Calculate relative velocity between player and puck
            const relativeVx = activeCharacter.momentum ? activeCharacter.momentum.x : (activeCharacter.vx || 0);
            const relativeVy = activeCharacter.momentum ? activeCharacter.momentum.y : (activeCharacter.vy || 0);
            const relativeDotProduct = (dx * relativeVx + dy * relativeVy) / kickDist;
            
            // Base kick force + bonus based on player speed and direction
            const speedBonus = Math.max(0, relativeDotProduct) * 0.5; // Bonus if moving toward puck
            const kickStrength = 1 + (playerSpeed / CONFIG.PLAYER_SPEED) * 0.5 + speedBonus;
            
            // Apply variable kick force
            const forceX = (dx / kickDist) * KICK_FORCE * kickStrength;
            const forceY = (dy / kickDist) * KICK_FORCE * kickStrength;
            
            gameState.puck.vx += forceX;
            gameState.puck.vy += forceY;
            
            // Set cooldown
            gameState.kickCooldowns[playerId] = 15; // Reduced cooldown for more responsive kicking
            
            // Visual effect - make player glow briefly
            if (activeCharacter) {
                activeCharacter.kickEffect = 10;
                // Stronger kicks get stronger visual effect
                activeCharacter.kickStrength = kickStrength;
            }
            
            return true;
        }
        
        // Update cooldowns
        function updateCooldowns() {
            for (let playerId = 1; playerId <= 3; playerId++) {
                if (gameState.kickCooldowns[playerId] > 0) {
                    gameState.kickCooldowns[playerId]--;
                }
            }
            
            // Update kick effects
            for (let playerId = 1; playerId <= 3; playerId++) {
                for (let roomName in gameState.playerCharacters[playerId]) {
                    const character = gameState.playerCharacters[playerId][roomName];
                    if (character.kickEffect > 0) {
                        character.kickEffect--;
                    }
                }
            }
        }
        // AI Logic - separate decision making from movement
        function updateAI(playerId) {
            if (gameState.playerTypes[playerId] !== 'ai') return;
            
            const settings = aiSettings[gameConfig.aiDifficulty];
            const aiState = gameState.aiState[playerId];
            const activeCharacter = getActiveCharacter(playerId);
            if (!activeCharacter) return;
            
            // Make decisions only occasionally (intelligence difference)
            if (gameState.gameTime - aiState.lastDecision >= settings.reactionTime) {
                makeAIDecision(playerId, settings, aiState, activeCharacter);
                aiState.lastDecision = gameState.gameTime;
            }
            
            // But ALWAYS move toward current target every frame (same speed as humans)
            if (aiState.target) {
                moveAITowardTarget(activeCharacter, aiState.target, playerId);
            }
            
            // AI Kicking logic with timing
            if (settings.strategy > 0.5) { // Only medium/hard AI kicks strategically
                const distToPuck = distance(activeCharacter, gameState.puck);
                if (distToPuck <= KICK_RANGE && gameState.kickCooldowns[playerId] === 0) {
                    // Check if we should delay the kick for better alignment
                    const delayKick = shouldDelayKick(playerId, activeCharacter, settings);
                    
                    if (!delayKick) {
                        // Decide whether to kick based on situation
                        const shouldKick = shouldAIKick(playerId, activeCharacter, settings);
                        if (shouldKick) {
                            tryKick(playerId);
                        }
                    }
                }
            }
        }
        
        function shouldAIKick(playerId, character, settings) {
            const currentRoom = gameState.puck.currentRoom;
            const aiState = gameState.aiState[playerId];
            
            // Don't kick randomly - only kick with purpose
            if (Math.random() > settings.strategy) return false;
            
            // Enhanced kicking decisions based on current strategy
            switch (aiState.strategy) {
                case 'shoot_on_goal':
                case 'attack':
                    // Always kick when in attacking mode and aligned with goal
                    const enemyGoal = getBestEnemyGoal(currentRoom, playerId);
                    if (enemyGoal) {
                        const alignment = calculateKickAlignment(character, gameState.puck, enemyGoal);
                        return alignment > 0.6; // Lower threshold for attacking
                    }
                    break;
                    
                case 'clear_puck':
                case 'urgent_defend':
                    // Always kick to clear danger
                    return true;
                    
                case 'goalkeeper':
                    // Goalkeeper kicks if puck is close and moving slowly
                    const puckSpeed = Math.sqrt(gameState.puck.vx * gameState.puck.vx + gameState.puck.vy * gameState.puck.vy);
                    if (puckSpeed < 3) {
                        return true; // Clear slow-moving pucks
                    }
                    break;
                    
                case 'escape_to_portal':
                    // Always kick toward portal when escaping
                    return true;
                    
                case 'push_to_portal':
                    // Enhanced portal targeting
                    if (currentRoom === 'center') {
                        const centerRoom = rooms['center'];
                        let bestPortal = null;
                        let bestScore = -1;
                        
                        for (const [targetRoom, tunnel] of Object.entries(centerRoom.connections)) {
                            if (targetRoom !== `player${playerId}_zone`) {
                                const portalX = centerRoom.x + tunnel.x;
                                const portalY = centerRoom.y + tunnel.y;
                                
                                const alignment = calculateKickAlignment(character, gameState.puck, {x: portalX, y: portalY});
                                const distance = Math.sqrt((portalX - character.x)**2 + (portalY - character.y)**2);
                                
                                // Score based on alignment and whether it's an enemy zone
                                let score = alignment;
                                if (targetRoom.includes('player') && !targetRoom.includes(`${playerId}`)) {
                                    score *= 1.5; // Prefer enemy zones
                                }
                                
                                // Smart AI considers distance too
                                if (settings.strategy > 0.8) {
                                    score *= (1000 - distance) / 1000; // Prefer closer portals
                                }
                                
                                if (score > bestScore && alignment > 0.5) {
                                    bestScore = score;
                                    bestPortal = { x: portalX, y: portalY, name: targetRoom };
                                }
                            }
                        }
                        
                        return bestPortal !== null;
                    }
                    break;
            }
            
            // General kicking logic with zone control
            if (currentRoom !== 'center') {
                const enemyGoal = getBestEnemyGoal(currentRoom, playerId);
                if (enemyGoal) {
                    const alignment = calculateKickAlignment(character, gameState.puck, enemyGoal);
                    const puckToGoal = distance(gameState.puck, enemyGoal);
                    
                    // Smart AI considers power-ups
                    let kickThreshold = 0.7;
                    if (gameState.powerUps.playerEffects[playerId].speed > 0) {
                        kickThreshold = 0.6; // More aggressive with speed boost
                    }
                    
                    if (alignment > kickThreshold && puckToGoal > 100) {
                        return true;
                    }
                }
            } else {
                // In center room - avoid kicking to opponent defensive zones
                const room = rooms[currentRoom];
                if (room && room.connections) {
                    // Check if kick would send puck toward opponent zone
                    for (const [zoneName, tunnel] of Object.entries(room.connections)) {
                        if (zoneName.includes('player') && !zoneName.includes(`${playerId}`)) {
                            const portalPos = { x: room.x + tunnel.x, y: room.y + tunnel.y };
                            const kickAlignment = calculateKickAlignment(character, gameState.puck, portalPos);
                            
                            // If kick would send puck to opponent zone, don't kick
                            if (kickAlignment > 0.8 && settings.strategy > 0.6) {
                                return false; // Smart AI avoids helping opponents
                            }
                        }
                    }
                }
            }
            
            // Defensive kicks
            if (isMyDefensiveZone(currentRoom, playerId)) {
                const myGoal = getMyGoal(currentRoom, playerId);
                if (myGoal) {
                    const puckToMyGoal = distance(gameState.puck, myGoal);
                    const threatLevel = evaluateThreatLevel(playerId);
                    
                    // Kick based on threat level
                    if (threatLevel > 0.5 || puckToMyGoal < 150) {
                        return true;
                    }
                }
            }
            
            return false;
        }
        
        function calculateKickAlignment(character, puck, target) {
            // Calculate how well aligned character is to kick puck toward target
            const charToPuckX = puck.x - character.x;
            const charToPuckY = puck.y - character.y;
            const puckToTargetX = target.x - puck.x;
            const puckToTargetY = target.y - puck.y;
            
            const charToPuckDist = Math.sqrt(charToPuckX * charToPuckX + charToPuckY * charToPuckY);
            const puckToTargetDist = Math.sqrt(puckToTargetX * puckToTargetX + puckToTargetY * puckToTargetY);
            
            if (charToPuckDist < 0.01 || puckToTargetDist < 0.01) return 0;
            
            // Normalize vectors
            const charToPuckNormX = charToPuckX / charToPuckDist;
            const charToPuckNormY = charToPuckY / charToPuckDist;
            const puckToTargetNormX = puckToTargetX / puckToTargetDist;
            const puckToTargetNormY = puckToTargetY / puckToTargetDist;
            
            // Calculate dot product (how aligned the vectors are)
            const dotProduct = charToPuckNormX * puckToTargetNormX + charToPuckNormY * puckToTargetNormY;
            
            // Return value between 0 and 1 (1 = perfect alignment)
            return Math.max(0, dotProduct);
        }
        
        function makeAIDecision(playerId, settings, aiState, activeCharacter) {
            const puckDistance = distance(activeCharacter, gameState.puck);
            const currentRoom = gameState.puck.currentRoom;
            const threatLevel = evaluateThreatLevel(playerId);
            
            // Check for power-up opportunities first (smart AI only)
            const powerUpTarget = shouldGoForPowerUp(playerId, activeCharacter, settings);
            if (powerUpTarget && threatLevel < 0.7) {
                aiState.strategy = 'get_powerup';
                aiState.powerUpTarget = powerUpTarget.box;
            }
            // Enhanced strategy decision based on multiple factors
            else if (Math.random() < settings.strategy) {
                // Smart strategic behavior with threat assessment
                if (threatLevel > 0.8) {
                    // High threat - prioritize defense
                    aiState.strategy = 'urgent_defend';
                } else if (currentRoom === 'center') {
                    // In center room - more complex decision making
                    const otherAIs = getOtherAIPlayers(playerId);
                    const hasTeammate = otherAIs.length > 0;
                    
                    if (puckDistance < 100) {
                        // Check if teammate is closer to puck
                        let teammateCloser = false;
                        otherAIs.forEach(ai => {
                            if (distance(ai.character, gameState.puck) < puckDistance - 30) {
                                teammateCloser = true;
                            }
                        });
                        
                        if (teammateCloser && settings.strategy > 0.7) {
                            // Let teammate handle puck, we position for pass
                            aiState.strategy = 'support';
                        } else {
                            aiState.strategy = 'push_to_portal';
                        }
                    } else {
                        // Smart positioning when far from puck
                        if (settings.strategy > 0.8 && hasTeammate) {
                            aiState.strategy = 'strategic_position';
                        } else {
                            aiState.strategy = 'intercept';
                        }
                    }
                } else if (isMyDefensiveZone(currentRoom, playerId)) {
                    // Enhanced defensive decision making
                    if (isAloneInDefensiveZone(playerId)) {
                        // Alone with only goal - push puck through portal for safety
                        aiState.strategy = 'escape_to_portal';
                    } else if (puckDistance < 200 && threatLevel > 0.5) {
                        aiState.strategy = 'urgent_defend';
                    } else if (puckDistance < 150) {
                        aiState.strategy = 'clear_puck';
                    } else {
                        aiState.strategy = 'goalkeeper';
                    }
                } else if (puckDistance < 100) {
                    // Close to puck - evaluate best action
                    const enemyGoal = getBestEnemyGoal(currentRoom, playerId);
                    if (enemyGoal && distance(activeCharacter, enemyGoal) < 300) {
                        aiState.strategy = 'shoot_on_goal';
                    } else {
                        aiState.strategy = 'attack';
                    }
                } else {
                    // Far from puck - intercept or position
                    const prediction = predictPuckPosition(settings.predictionFrames * 2);
                    const futureDist = distance(activeCharacter, prediction);
                    
                    if (futureDist < puckDistance) {
                        aiState.strategy = 'intercept';
                    } else {
                        aiState.strategy = 'position';
                    }
                }
            } else {
                // Simple AI behavior - just follow the ball
                aiState.strategy = 'follow';
            }
            
            // Set target based on strategy
            let targetX = activeCharacter.x;
            let targetY = activeCharacter.y;
            
            switch (aiState.strategy) {
                case 'follow':
                    // Simple: just go to where ball is now
                    targetX = gameState.puck.x;
                    targetY = gameState.puck.y;
                    break;
                    
                case 'intercept':
                    // Smart: predict where puck will be
                    const prediction = predictPuckPosition(settings.predictionFrames);
                    targetX = prediction.x;
                    targetY = prediction.y;
                    break;
                    
                case 'defend':
                    const myGoal = getMyGoal(currentRoom, playerId);
                    if (myGoal) {
                        // Position between puck and goal
                        const dx = gameState.puck.x - myGoal.x;
                        const dy = gameState.puck.y - myGoal.y;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        const defensiveDistance = 80;
                        
                        targetX = myGoal.x + (dx / dist) * defensiveDistance;
                        targetY = myGoal.y + (dy / dist) * defensiveDistance;
                    }
                    break;
                    
                case 'attack':
                    const enemyGoal = getBestEnemyGoal(currentRoom, playerId);
                    if (enemyGoal) {
                        // Smart AI aims better, dumb AI has more spread
                        const inaccuracy = (1 - settings.accuracy) * 120;
                        targetX = enemyGoal.x + (Math.random() - 0.5) * inaccuracy;
                        targetY = enemyGoal.y + (Math.random() - 0.5) * inaccuracy;
                    } else {
                        // No enemy goal visible, go for ball
                        targetX = gameState.puck.x;
                        targetY = gameState.puck.y;
                    }
                    break;
                    
                case 'position':
                    // Strategic positioning based on game state
                    const room = rooms[currentRoom];
                    if (currentRoom === 'frantic_zone') {
                        // In frantic zone, stay central but avoid other players
                        targetX = room.x + (Math.random() - 0.5) * 200;
                        targetY = room.y + (Math.random() - 0.5) * 200;
                    } else {
                        // In other rooms, position strategically
                        targetX = room.x + (Math.random() - 0.5) * room.width * 0.4;
                        targetY = room.y + (Math.random() - 0.5) * room.height * 0.4;
                    }
                    break;
                    
                case 'push_to_portal':
                    // In center room - find best portal to push puck toward
                    const centerRoom = rooms['center'];
                    const portals = [];
                    
                    // Collect all portals except the one leading to our defensive zone
                    for (const [targetRoom, tunnel] of Object.entries(centerRoom.connections)) {
                        if (targetRoom !== `player${playerId}_zone`) {
                            portals.push({
                                name: targetRoom,
                                x: centerRoom.x + tunnel.x,
                                y: centerRoom.y + tunnel.y,
                                tunnel: tunnel
                            });
                        }
                    }
                    
                    // Find the best portal based on AI intelligence
                    if (portals.length > 0) {
                        let bestPortal;
                        
                        if (settings.strategy > 0.7) {
                            // Smart AI: Choose portal that leads to enemy defensive zone
                            const enemyPortals = portals.filter(p => 
                                p.name.includes('player') && !p.name.includes(`player${playerId}`)
                            );
                            bestPortal = enemyPortals.length > 0 ? 
                                enemyPortals[Math.floor(Math.random() * enemyPortals.length)] : 
                                portals[Math.floor(Math.random() * portals.length)];
                        } else {
                            // Simple AI: Choose random portal
                            bestPortal = portals[Math.floor(Math.random() * portals.length)];
                        }
                        
                        // Position behind puck to push it toward portal
                        const puckToPortalX = bestPortal.x - gameState.puck.x;
                        const puckToPortalY = bestPortal.y - gameState.puck.y;
                        const dist = Math.sqrt(puckToPortalX * puckToPortalX + puckToPortalY * puckToPortalY);
                        
                        if (dist > 0) {
                            // Get behind the puck relative to the portal
                            targetX = gameState.puck.x - (puckToPortalX / dist) * 50;
                            targetY = gameState.puck.y - (puckToPortalY / dist) * 50;
                        }
                    }
                    break;
                    
                case 'get_powerup':
                    // Go for power-up
                    if (aiState.powerUpTarget) {
                        targetX = aiState.powerUpTarget.x;
                        targetY = aiState.powerUpTarget.y;
                    }
                    break;
                    
                case 'urgent_defend':
                    // Emergency defensive positioning
                    const urgentGoal = getMyGoal(currentRoom, playerId);
                    if (urgentGoal) {
                        const optimalPos = getOptimalDefensivePosition(playerId, urgentGoal);
                        targetX = optimalPos.x;
                        targetY = optimalPos.y;
                    }
                    break;
                    
                case 'clear_puck':
                    // Get behind puck to clear it away from our goal
                    const clearGoal = getMyGoal(currentRoom, playerId);
                    if (clearGoal) {
                        const puckToGoalX = clearGoal.x - gameState.puck.x;
                        const puckToGoalY = clearGoal.y - gameState.puck.y;
                        const dist = Math.sqrt(puckToGoalX * puckToGoalX + puckToGoalY * puckToGoalY);
                        
                        if (dist > 0) {
                            // Position behind puck relative to our goal
                            targetX = gameState.puck.x - (puckToGoalX / dist) * 40;
                            targetY = gameState.puck.y - (puckToGoalY / dist) * 40;
                        }
                    }
                    break;
                    
                case 'shoot_on_goal':
                    // Position for optimal shot on enemy goal
                    const shootGoal = getBestEnemyGoal(currentRoom, playerId);
                    if (shootGoal) {
                        // Get behind puck for a shot
                        const puckToGoalX = shootGoal.x - gameState.puck.x;
                        const puckToGoalY = shootGoal.y - gameState.puck.y;
                        const dist = Math.sqrt(puckToGoalX * puckToGoalX + puckToGoalY * puckToGoalY);
                        
                        if (dist > 0) {
                            targetX = gameState.puck.x - (puckToGoalX / dist) * 35;
                            targetY = gameState.puck.y - (puckToGoalY / dist) * 35;
                        }
                    }
                    break;
                    
                case 'support':
                    // Position to support teammate who has the puck
                    const supportRoom = rooms[currentRoom];
                    if (supportRoom) {
                        // Position ahead of puck movement for potential pass
                        const futurePos = predictPuckPosition(15);
                        targetX = futurePos.x + (Math.random() - 0.5) * 100;
                        targetY = futurePos.y + (Math.random() - 0.5) * 100;
                        
                        // Stay within room bounds
                        targetX = Math.max(supportRoom.x - supportRoom.width/2 + 50, 
                                         Math.min(targetX, supportRoom.x + supportRoom.width/2 - 50));
                        targetY = Math.max(supportRoom.y - supportRoom.height/2 + 50,
                                         Math.min(targetY, supportRoom.y + supportRoom.height/2 - 50));
                    }
                    break;
                    
                case 'strategic_position':
                    // Advanced positioning based on game state
                    const stratRoom = rooms[currentRoom];
                    if (stratRoom) {
                        // Position based on multiple factors
                        const puckVel = Math.sqrt(gameState.puck.vx * gameState.puck.vx + gameState.puck.vy * gameState.puck.vy);
                        
                        if (puckVel < 2) {
                            // Puck is slow - position aggressively
                            const midpointX = (gameState.puck.x + activeCharacter.x) / 2;
                            const midpointY = (gameState.puck.y + activeCharacter.y) / 2;
                            targetX = midpointX;
                            targetY = midpointY;
                        } else {
                            // Puck is fast - predict and intercept
                            const longPrediction = predictPuckPosition(30);
                            targetX = longPrediction.x;
                            targetY = longPrediction.y;
                        }
                    }
                    break;
                    
                case 'goalkeeper':
                    // Optimal goalkeeper positioning
                    const gkGoal = getMyGoal(currentRoom, playerId);
                    if (gkGoal) {
                        const optimalGKPos = getGoalkeeperPosition(playerId, gameState.puck, gkGoal);
                        targetX = optimalGKPos.x;
                        targetY = optimalGKPos.y;
                    }
                    break;
                    
                case 'escape_to_portal':
                    // Push puck through portal when alone in defensive zone
                    const escapeRoom = rooms[currentRoom];
                    if (escapeRoom && escapeRoom.connections) {
                        // Find the portal (there should only be one in defensive zones)
                        const portalEntry = Object.entries(escapeRoom.connections)[0];
                        if (portalEntry) {
                            const [portalName, tunnel] = portalEntry;
                            const portalX = escapeRoom.x + tunnel.x;
                            const portalY = escapeRoom.y + tunnel.y;
                            
                            // Get behind puck to push toward portal
                            const puckToPortalX = portalX - gameState.puck.x;
                            const puckToPortalY = portalY - gameState.puck.y;
                            const dist = Math.sqrt(puckToPortalX * puckToPortalX + puckToPortalY * puckToPortalY);
                            
                            if (dist > 0) {
                                targetX = gameState.puck.x - (puckToPortalX / dist) * 40;
                                targetY = gameState.puck.y - (puckToPortalY / dist) * 40;
                            }
                        }
                    }
                    break;
            }
            
            // Store target for continuous movement
            aiState.target = { x: targetX, y: targetY };
        }
        
        function moveAITowardTarget(character, target, playerId) {
            const dx = target.x - character.x;
            const dy = target.y - character.y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            
            if (dist < 10) {
                // Apply friction when at target
                if (character.momentum) {
                    character.momentum.x *= 0.85;
                    character.momentum.y *= 0.85;
                }
                return;
            }
            
            // Initialize momentum if not exists
            if (character.momentum === undefined) {
                character.momentum = { x: 0, y: 0 };
            }
            
            const aiState = gameState.aiState[playerId];
            
            // Check if AI is stuck (hasn't moved much)
            const movedDistance = distance(character, aiState.lastPos);
            if (movedDistance < 1) {
                aiState.stuckCounter++;
            } else {
                aiState.stuckCounter = Math.max(0, aiState.stuckCounter - 1);
            }
            
            // EXACT same speed as human players!
            const speedBoost = gameState.powerUps.playerEffects[playerId].speed > 0 ? 1.5 : 1;
            const slowdownFactor = gameState.powerUps.playerEffects[playerId].slowdown > 0 ? 0.5 : 1;
            const speed = CONFIG.PLAYER_SPEED * speedBoost * slowdownFactor;
            
            // Target velocity
            let targetVx = (dx / dist) * speed;
            let targetVy = (dy / dist) * speed;
            
            // Anti-stuck behavior
            if (aiState.stuckCounter > CONFIG.STUCK_THRESHOLD) {
                // Add random movement to escape corners
                const randomAngle = Math.random() * Math.PI * 2;
                const randomForce = CONFIG.ANTI_STUCK_FORCE;
                targetVx += Math.cos(randomAngle) * randomForce;
                targetVy += Math.sin(randomAngle) * randomForce;
                
                // Reset counter after escape attempt
                if (aiState.stuckCounter > CONFIG.STUCK_RESET) {
                    aiState.stuckCounter = 0;
                }
            }
            
            // Apply acceleration to momentum (AI uses slightly higher acceleration for responsiveness)
            const acceleration = 0.4;
            character.momentum.x += (targetVx - character.momentum.x) * acceleration;
            character.momentum.y += (targetVy - character.momentum.y) * acceleration;
            
            // Store current position for next frame
            aiState.lastPos = { x: character.x, y: character.y };
            
            // Apply momentum to position
            character.x += character.momentum.x;
            character.y += character.momentum.y;
            
            // Update visual velocity
            character.vx = character.momentum.x * 0.8;
            character.vy = character.momentum.y * 0.8;
            
            // Constrain to current room
            const currentRoom = gameState.puck.currentRoom;
            constrainCharacterToRoom(character, currentRoom);
        }
        
        function getActiveCharacter(playerId) {
            const currentRoom = gameState.puck.currentRoom;
            const character = gameState.playerCharacters[playerId][currentRoom];
            return character && character.active ? character : null;
        }
        
        function distance(a, b) {
            return Math.sqrt((a.x - b.x) ** 2 + (a.y - b.y) ** 2);
        }
        
        function adjustBrightness(color, amount) {
            // Convert hex to RGB
            const hex = color.replace('#', '');
            const r = parseInt(hex.substr(0, 2), 16);
            const g = parseInt(hex.substr(2, 2), 16);
            const b = parseInt(hex.substr(4, 2), 16);
            
            // Adjust brightness
            const newR = Math.max(0, Math.min(255, r + amount));
            const newG = Math.max(0, Math.min(255, g + amount));
            const newB = Math.max(0, Math.min(255, b + amount));
            
            // Convert back to hex
            return '#' + ((1 << 24) + (newR << 16) + (newG << 8) + newB).toString(16).slice(1);
        }
        
        function isMyDefensiveZone(roomName, playerId) {
            return roomName === `player${playerId}_zone`;
        }
        
        function getMyGoal(roomName, playerId) {
            const room = rooms[roomName];
            if (!room || !room.goals) return null;
            
            const myGoal = room.goals.find(goal => goal.owner === playerId);
            if (!myGoal) return null;
            
            return {
                x: room.x + myGoal.x,
                y: room.y + myGoal.y
            };
        }
        
        function getBestEnemyGoal(roomName, playerId) {
            const room = rooms[roomName];
            if (!room || !room.goals) return null;
            
            const enemyGoals = room.goals.filter(goal => goal.owner !== playerId);
            if (enemyGoals.length === 0) return null;
            
            // Pick closest enemy goal
            const activeChar = getActiveCharacter(playerId);
            let bestGoal = null;
            let bestDistance = Infinity;
            
            enemyGoals.forEach(goal => {
                const goalPos = { x: room.x + goal.x, y: room.y + goal.y };
                const dist = distance(activeChar, goalPos);
                if (dist < bestDistance) {
                    bestDistance = dist;
                    bestGoal = goalPos;
                }
            });
            
            return bestGoal;
        }
        
        function predictPuckPosition(frames) {
            // Enhanced prediction with physics simulation
            let futureX = gameState.puck.x;
            let futureY = gameState.puck.y;
            let vx = gameState.puck.vx;
            let vy = gameState.puck.vy;
            
            // Simulate physics for each frame
            for (let i = 0; i < frames; i++) {
                // Apply friction
                vx *= FRICTION;
                vy *= FRICTION;
                
                // Update position
                futureX += vx;
                futureY += vy;
                
                // Simple wall bounce prediction (room boundaries)
                const room = rooms[gameState.puck.currentRoom];
                if (room) {
                    const minX = room.x - room.width/2 + PUCK_RADIUS;
                    const maxX = room.x + room.width/2 - PUCK_RADIUS;
                    const minY = room.y - room.height/2 + PUCK_RADIUS;
                    const maxY = room.y + room.height/2 - PUCK_RADIUS;
                    
                    if (futureX < minX || futureX > maxX) vx *= -CONFIG.WALL_BOUNCE;
                    if (futureY < minY || futureY > maxY) vy *= -CONFIG.WALL_BOUNCE;
                }
            }
            
            return { x: futureX, y: futureY };
        }
        
        function isMovingTowardMyGoal(playerId) {
            const myGoal = getMyGoal(gameState.puck.currentRoom, playerId);
            if (!myGoal) return false;
            
            // Check if puck is moving toward my goal
            const futurePos = predictPuckPosition(10);
            const currentDist = distance(gameState.puck, myGoal);
            const futureDist = distance(futurePos, myGoal);
            
            return futureDist < currentDist;
        }
        
        // New AI helper functions for enhanced complexity
        function getOtherAIPlayers(excludePlayerId) {
            const aiPlayers = [];
            for (let id = 1; id <= 3; id++) {
                if (id !== excludePlayerId && gameState.playerTypes[id] === 'ai') {
                    const char = getActiveCharacter(id);
                    if (char) {
                        aiPlayers.push({ id, character: char });
                    }
                }
            }
            return aiPlayers;
        }
        
        function getNearestPowerUp(character) {
            if (!gameState.powerUps.boxes || gameState.powerUps.boxes.length === 0) return null;
            
            let nearest = null;
            let nearestDist = Infinity;
            
            gameState.powerUps.boxes.forEach(box => {
                const dist = distance(character, box);
                if (dist < nearestDist) {
                    nearestDist = dist;
                    nearest = { box, distance: dist };
                }
            });
            
            return nearest;
        }
        
        function shouldGoForPowerUp(playerId, character, settings) {
            const powerUp = getNearestPowerUp(character);
            if (!powerUp) return false;
            
            // Smart AI evaluates if power-up is worth going for
            if (settings.strategy < 0.6) return false; // Only medium/hard AI goes for power-ups
            
            const puckDist = distance(character, gameState.puck);
            const powerUpDist = powerUp.distance;
            
            // Consider power-up if it's closer than puck or if we're not in immediate danger
            if (powerUpDist < puckDist * 0.7) {
                // Check if we already have too many power-ups
                const activeEffects = gameState.powerUps.playerEffects[playerId];
                const activeCount = Object.values(activeEffects).filter(v => v > 0).length;
                
                if (activeCount < 2) {
                    // Check if puck is threatening our goal
                    if (!isMovingTowardMyGoal(playerId) || puckDist > 200) {
                        return powerUp;
                    }
                }
            }
            
            return false;
        }
        
        function getOptimalDefensivePosition(playerId, myGoal) {
            // Calculate optimal defensive position based on puck trajectory
            const prediction = predictPuckPosition(20);
            const puckToGoalX = myGoal.x - gameState.puck.x;
            const puckToGoalY = myGoal.y - gameState.puck.y;
            const dist = Math.sqrt(puckToGoalX * puckToGoalX + puckToGoalY * puckToGoalY);
            
            if (dist < 0.01) return myGoal; // Puck is at goal
            
            // Position between predicted puck position and goal
            const defensiveRatio = 0.3; // Stay 30% of distance from goal
            const optimalX = myGoal.x - (puckToGoalX / dist) * (dist * defensiveRatio);
            const optimalY = myGoal.y - (puckToGoalY / dist) * (dist * defensiveRatio);
            
            return { x: optimalX, y: optimalY };
        }
        
        function evaluateThreatLevel(playerId) {
            // Evaluate how dangerous the current situation is
            const myGoal = getMyGoal(gameState.puck.currentRoom, playerId);
            if (!myGoal) return 0;
            
            const puckDist = distance(gameState.puck, myGoal);
            const puckSpeed = Math.sqrt(gameState.puck.vx * gameState.puck.vx + gameState.puck.vy * gameState.puck.vy);
            const movingToward = isMovingTowardMyGoal(playerId);
            
            let threatLevel = 0;
            
            if (movingToward) {
                threatLevel += 0.5;
                if (puckDist < 200) threatLevel += 0.3;
                if (puckSpeed > 5) threatLevel += 0.2;
            }
            
            return Math.min(threatLevel, 1);
        }
        
        function isAloneInDefensiveZone(playerId) {
            const currentRoom = gameState.puck.currentRoom;
            if (!isMyDefensiveZone(currentRoom, playerId)) return false;
            
            // Check if any other players are active in this room
            for (let i = 1; i <= 3; i++) {
                if (i !== playerId) {
                    const char = gameState.playerCharacters[i][currentRoom];
                    if (char && char.active) {
                        return false;
                    }
                }
            }
            return true;
        }
        
        function getGoalkeeperPosition(playerId, puckPos, goalPos) {
            // Optimal goalkeeper position between puck and goal
            const dx = puckPos.x - goalPos.x;
            const dy = puckPos.y - goalPos.y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            
            if (dist < 0.01) return goalPos;
            
            // Position 80-120 units from goal depending on puck distance
            const optimalDist = Math.min(120, Math.max(80, dist * 0.3));
            
            return {
                x: goalPos.x + (dx / dist) * optimalDist,
                y: goalPos.y + (dy / dist) * optimalDist
            };
        }
        
        function shouldDelayKick(playerId, character, settings) {
            // Determine if AI should wait for better kick opportunity
            const currentRoom = gameState.puck.currentRoom;
            const aiState = gameState.aiState[playerId];
            
            // Don't delay if defending urgently
            if (aiState.strategy === 'urgent_defend' || aiState.strategy === 'clear_puck') {
                return false;
            }
            
            // Check kick alignment with intended target
            let targetAlignment = 0;
            if (aiState.strategy === 'shoot_on_goal' || aiState.strategy === 'attack') {
                const enemyGoal = getBestEnemyGoal(currentRoom, playerId);
                if (enemyGoal) {
                    targetAlignment = calculateKickAlignment(character, gameState.puck, enemyGoal);
                }
            } else if (aiState.strategy === 'push_to_portal') {
                // Check alignment with best portal
                const room = rooms[currentRoom];
                if (room && room.connections) {
                    let bestPortalAlignment = 0;
                    for (const [name, tunnel] of Object.entries(room.connections)) {
                        const portalPos = { x: room.x + tunnel.x, y: room.y + tunnel.y };
                        const alignment = calculateKickAlignment(character, gameState.puck, portalPos);
                        bestPortalAlignment = Math.max(bestPortalAlignment, alignment);
                    }
                    targetAlignment = bestPortalAlignment;
                }
            }
            
            // Delay kick if alignment is poor (less than 70% for smart AI)
            const alignmentThreshold = settings.strategy > 0.7 ? 0.7 : 0.5;
            return targetAlignment < alignmentThreshold;
        }
        
        
        // Initialize game
        function init() {
            gameState.puck.x = 0;
            gameState.puck.y = 0;
            gameState.puck.vx = (Math.random() - 0.5) * 4;
            gameState.puck.vy = (Math.random() - 0.5) * 4;
            gameState.puck.currentRoom = 'center';
            gameState.puck.trail = [];
            
            // Reset character positions - adjusted for new room spacing
            gameState.playerCharacters[1].center = { x: -100, y: -100, active: false, vx: 0, vy: 0 };
            gameState.playerCharacters[1].player1_zone = { x: 0, y: -ROOM_SIZE * ROOM_SPACING - 100, active: false, vx: 0, vy: 0 };
            gameState.playerCharacters[1].player2_zone = { x: ROOM_SIZE * ROOM_SPACING + 100, y: -100, active: false, vx: 0, vy: 0 };
            gameState.playerCharacters[1].player3_zone = { x: -ROOM_SIZE * ROOM_SPACING - 100, y: -100, active: false, vx: 0, vy: 0 };
            gameState.playerCharacters[1].frantic_zone = { x: -100, y: ROOM_SIZE * ROOM_SPACING + 100, active: false, vx: 0, vy: 0 };
            
            gameState.playerCharacters[2].center = { x: 0, y: 0, active: false, vx: 0, vy: 0 };
            gameState.playerCharacters[2].player1_zone = { x: 0, y: -ROOM_SIZE * ROOM_SPACING, active: false, vx: 0, vy: 0 };
            gameState.playerCharacters[2].player2_zone = { x: ROOM_SIZE * ROOM_SPACING, y: 0, active: false, vx: 0, vy: 0 };
            gameState.playerCharacters[2].player3_zone = { x: -ROOM_SIZE * ROOM_SPACING, y: 0, active: false, vx: 0, vy: 0 };
            gameState.playerCharacters[2].frantic_zone = { x: 0, y: ROOM_SIZE * ROOM_SPACING, active: false, vx: 0, vy: 0 };
            
            gameState.playerCharacters[3].center = { x: 100, y: 100, active: false, vx: 0, vy: 0 };
            gameState.playerCharacters[3].player1_zone = { x: 100, y: -ROOM_SIZE * ROOM_SPACING + 100, active: false, vx: 0, vy: 0 };
            gameState.playerCharacters[3].player2_zone = { x: ROOM_SIZE * ROOM_SPACING - 100, y: 100, active: false, vx: 0, vy: 0 };
            gameState.playerCharacters[3].player3_zone = { x: -ROOM_SIZE * ROOM_SPACING + 100, y: 100, active: false, vx: 0, vy: 0 };
            gameState.playerCharacters[3].frantic_zone = { x: 100, y: ROOM_SIZE * ROOM_SPACING - 100, active: false, vx: 0, vy: 0 };
            
            gameState.currentRoom = 'center';
            updateActiveCharacters();
            updateRoomIndicator();
            updatePuckDisplay();
        }
        
        // Update which characters are active based on puck location
        function updateActiveCharacters() {
            const currentRoom = gameState.puck.currentRoom;
            
            // Deactivate all characters first
            for (let playerId = 1; playerId <= 3; playerId++) {
                for (let roomName in gameState.playerCharacters[playerId]) {
                    gameState.playerCharacters[playerId][roomName].active = false;
                }
            }
            
            // Activate characters in the current room
            for (let playerId = 1; playerId <= 3; playerId++) {
                if (gameState.playerCharacters[playerId][currentRoom]) {
                    gameState.playerCharacters[playerId][currentRoom].active = true;
                }
            }
            
            updateActivePlayerDisplay();
        }
        
        function updatePuckDisplay() {
            const puckX = Math.round(gameState.puck.x);
            const puckY = Math.round(gameState.puck.y);
            document.getElementById('puckPosition').textContent = `${puckX},${puckY}`;
        }
        
        function updateActivePlayerDisplay() {
            const currentRoom = gameState.puck.currentRoom;
            const roomNames = {
                center: 'Center',
                player1_zone: 'Player 1 Zone',
                player2_zone: 'Player 2 Zone', 
                player3_zone: 'Player 3 Zone',
                frantic_zone: 'FRANTIC ZONE!'
            };
            document.getElementById('activePlayers').textContent = roomNames[currentRoom] || currentRoom;
        }
        
        // Input handling
        document.addEventListener('keydown', (e) => {
            if (!gameConfig.gameStarted) return;
            
            gameState.keys[e.key.toLowerCase()] = true;
            
            // Kick controls - mapped to be near movement keys
            if (e.key === ' ' && gameState.playerTypes[1] === 'human') { // Space for Player 1 (arrows)
                e.preventDefault();
                tryKick(1);
            }
            if (e.key === 'Shift' && e.location === 1 && gameState.playerTypes[2] === 'human') { // Left Shift for Player 2 (WASD)
                e.preventDefault();
                tryKick(2);
            }
            if (e.key.toLowerCase() === 'h' && gameState.playerTypes[3] === 'human') { // H for Player 3 (IJKL)
                e.preventDefault();
                tryKick(3);
            }
            
            if (e.key.toLowerCase() === 'r') {
                e.preventDefault();
                init();
            }
            if (e.key === 'Escape') {
                e.preventDefault();
                gameState.isPaused = !gameState.isPaused;
            }
            if (e.key.toLowerCase() === 'm') {
                e.preventDefault();
                showMenu();
            }
        });
        
        document.addEventListener('keyup', (e) => {
            gameState.keys[e.key.toLowerCase()] = false;
        });
        
        // Enhanced collision detection
        function isPointInRoom(x, y, roomName) {
            const room = rooms[roomName];
            return Math.abs(x - room.x) <= room.width/2 && 
                   Math.abs(y - room.y) <= room.height/2;
        }
        
        function isPointInTunnel(x, y) {
            for (const [roomName, room] of Object.entries(rooms)) {
                for (const [connectionName, tunnel] of Object.entries(room.connections)) {
                    const tunnelX = room.x + tunnel.x;
                    const tunnelY = room.y + tunnel.y;
                    
                    if (Math.abs(x - tunnelX) <= tunnel.width/2 && 
                        Math.abs(y - tunnelY) <= tunnel.height/2) {
                        return true;
                    }
                }
            }
            return false;
        }
        
        function constrainCharacterToRoom(character, roomName) {
            const room = rooms[roomName];
            const cornerRadius = CONFIG.CORNER_RADIUS;
            
            const left = room.x - room.width/2 + PADDLE_RADIUS;
            const right = room.x + room.width/2 - PADDLE_RADIUS;
            const top = room.y - room.height/2 + PADDLE_RADIUS;
            const bottom = room.y + room.height/2 - PADDLE_RADIUS;
            
            // First constrain to basic rectangle
            character.x = Math.max(left, Math.min(right, character.x));
            character.y = Math.max(top, Math.min(bottom, character.y));
            
            // Check rounded corners
            const corners = [
                { x: left + cornerRadius, y: top + cornerRadius },    // Top-left
                { x: right - cornerRadius, y: top + cornerRadius },   // Top-right
                { x: left + cornerRadius, y: bottom - cornerRadius },  // Bottom-left
                { x: right - cornerRadius, y: bottom - cornerRadius }  // Bottom-right
            ];
            
            // Check each corner
            for (let i = 0; i < corners.length; i++) {
                const corner = corners[i];
                const inCornerX = (i % 2 === 0) ? character.x < corner.x : character.x > corner.x;
                const inCornerY = (i < 2) ? character.y < corner.y : character.y > corner.y;
                
                if (inCornerX && inCornerY) {
                    const dist = distance(character, corner);
                    if (dist > cornerRadius) {
                        // Push character out of rounded corner
                        const angle = Math.atan2(character.y - corner.y, character.x - corner.x);
                        character.x = corner.x + Math.cos(angle) * cornerRadius;
                        character.y = corner.y + Math.sin(angle) * cornerRadius;
                    }
                }
            }
        }
        
        // Update game logic
        function update() {
            if (!gameConfig.gameStarted || gameState.isPaused) return;
            
            gameState.gameTime++;
            
            // Update cooldowns and effects
            updateCooldowns();
            updateBounceEffects();
            
            // Update portal transition
            updatePortalTransition();
            
            // Update power-ups
            spawnPowerUp();
            updatePowerUps();
            updatePowerUpDisplay();
            
            // Move characters (human input + AI)
            const baseSpeed = CONFIG.PLAYER_SPEED;
            
            // Player 1
            if (gameState.playerTypes[1] === 'human') {
                for (let roomName in gameState.playerCharacters[1]) {
                    const character = gameState.playerCharacters[1][roomName];
                    if (character.active) {
                        let moveX = 0, moveY = 0;
                        if (gameState.keys['arrowup']) moveY -= 1;
                        if (gameState.keys['arrowdown']) moveY += 1;
                        if (gameState.keys['arrowleft']) moveX -= 1;
                        if (gameState.keys['arrowright']) moveX += 1;
                        
                        // Initialize momentum if not exists
                        if (character.momentum === undefined) {
                            character.momentum = { x: 0, y: 0 };
                        }
                        
                        const speedBoost = gameState.powerUps.playerEffects[1].speed > 0 ? 1.5 : 1;
                        const slowdownFactor = gameState.powerUps.playerEffects[1].slowdown > 0 ? 0.5 : 1;
                        const speed = baseSpeed * speedBoost * slowdownFactor;
                        
                        // Apply acceleration to momentum
                        const acceleration = 0.3; // How quickly player accelerates
                        const friction = 0.85; // How quickly player slows down
                        
                        if (moveX !== 0 || moveY !== 0) {
                            // Normalize diagonal movement
                            const length = Math.sqrt(moveX * moveX + moveY * moveY);
                            const targetVx = (moveX / length) * speed;
                            const targetVy = (moveY / length) * speed;
                            
                            // Accelerate toward target velocity
                            character.momentum.x += (targetVx - character.momentum.x) * acceleration;
                            character.momentum.y += (targetVy - character.momentum.y) * acceleration;
                        } else {
                            // Apply friction when not moving
                            character.momentum.x *= friction;
                            character.momentum.y *= friction;
                        }
                        
                        // Apply momentum to position
                        character.x += character.momentum.x;
                        character.y += character.momentum.y;
                        
                        // Update visual velocity
                        character.vx = character.momentum.x * 0.8;
                        character.vy = character.momentum.y * 0.8;
                        
                        constrainCharacterToRoom(character, roomName);
                    }
                }
            } else {
                updateAI(1);
            }
            
            // Player 2
            if (gameState.playerTypes[2] === 'human') {
                for (let roomName in gameState.playerCharacters[2]) {
                    const character = gameState.playerCharacters[2][roomName];
                    if (character.active) {
                        let moveX = 0, moveY = 0;
                        if (gameState.keys['w']) moveY -= 1;
                        if (gameState.keys['s']) moveY += 1;
                        if (gameState.keys['a']) moveX -= 1;
                        if (gameState.keys['d']) moveX += 1;
                        
                        // Initialize momentum if not exists
                        if (character.momentum === undefined) {
                            character.momentum = { x: 0, y: 0 };
                        }
                        
                        const speedBoost = gameState.powerUps.playerEffects[2].speed > 0 ? 1.5 : 1;
                        const slowdownFactor = gameState.powerUps.playerEffects[2].slowdown > 0 ? 0.5 : 1;
                        const speed = baseSpeed * speedBoost * slowdownFactor;
                        
                        // Apply acceleration to momentum
                        const acceleration = 0.3;
                        const friction = 0.85;
                        
                        if (moveX !== 0 || moveY !== 0) {
                            const length = Math.sqrt(moveX * moveX + moveY * moveY);
                            const targetVx = (moveX / length) * speed;
                            const targetVy = (moveY / length) * speed;
                            
                            character.momentum.x += (targetVx - character.momentum.x) * acceleration;
                            character.momentum.y += (targetVy - character.momentum.y) * acceleration;
                        } else {
                            character.momentum.x *= friction;
                            character.momentum.y *= friction;
                        }
                        
                        character.x += character.momentum.x;
                        character.y += character.momentum.y;
                        character.vx = character.momentum.x * 0.8;
                        character.vy = character.momentum.y * 0.8;
                        
                        constrainCharacterToRoom(character, roomName);
                    }
                }
            } else {
                updateAI(2);
            }
            
            // Player 3
            if (gameState.playerTypes[3] === 'human') {
                for (let roomName in gameState.playerCharacters[3]) {
                    const character = gameState.playerCharacters[3][roomName];
                    if (character.active) {
                        let moveX = 0, moveY = 0;
                        if (gameState.keys['i']) moveY -= 1;
                        if (gameState.keys['k']) moveY += 1;
                        if (gameState.keys['j']) moveX -= 1;
                        if (gameState.keys['l']) moveX += 1;
                        
                        // Initialize momentum if not exists
                        if (character.momentum === undefined) {
                            character.momentum = { x: 0, y: 0 };
                        }
                        
                        const speedBoost = gameState.powerUps.playerEffects[3].speed > 0 ? 1.5 : 1;
                        const slowdownFactor = gameState.powerUps.playerEffects[3].slowdown > 0 ? 0.5 : 1;
                        const speed = baseSpeed * speedBoost * slowdownFactor;
                        
                        // Apply acceleration to momentum
                        const acceleration = 0.3;
                        const friction = 0.85;
                        
                        if (moveX !== 0 || moveY !== 0) {
                            const length = Math.sqrt(moveX * moveX + moveY * moveY);
                            const targetVx = (moveX / length) * speed;
                            const targetVy = (moveY / length) * speed;
                            
                            character.momentum.x += (targetVx - character.momentum.x) * acceleration;
                            character.momentum.y += (targetVy - character.momentum.y) * acceleration;
                        } else {
                            character.momentum.x *= friction;
                            character.momentum.y *= friction;
                        }
                        
                        character.x += character.momentum.x;
                        character.y += character.momentum.y;
                        character.vx = character.momentum.x * 0.8;
                        character.vy = character.momentum.y * 0.8;
                        
                        constrainCharacterToRoom(character, roomName);
                    }
                }
            } else {
                updateAI(3);
            }
            
            // Update puck physics (skip during portal transition)
            if (!gameState.portalTransition.active) {
                updatePuck();
            }
            
            // Update camera
            const targetCameraX = gameState.puck.x - canvas.width / 2;
            const targetCameraY = gameState.puck.y - canvas.height / 2;
            gameState.camera.x += (targetCameraX - gameState.camera.x) * 0.08;
            gameState.camera.y += (targetCameraY - gameState.camera.y) * 0.08;
            
            // Update puck position display
            updatePuckDisplay();
            
            // Check for goals
            checkGoals();
        }
        
        function updatePuck() {
            // Apply friction
            gameState.puck.vx *= FRICTION;
            gameState.puck.vy *= FRICTION;
            
            // Limit max speed
            const speed = Math.sqrt(gameState.puck.vx ** 2 + gameState.puck.vy ** 2);
            if (speed > MAX_SPEED) {
                gameState.puck.vx = (gameState.puck.vx / speed) * MAX_SPEED;
                gameState.puck.vy = (gameState.puck.vy / speed) * MAX_SPEED;
            }
            
            // Update trail
            gameState.puck.trail.push({x: gameState.puck.x, y: gameState.puck.y});
            if (gameState.puck.trail.length > CONFIG.TRAIL_LENGTH) {
                gameState.puck.trail.shift();
            }
            
            // Step-wise movement to prevent tunneling through walls
            const steps = Math.ceil(Math.sqrt(gameState.puck.vx ** 2 + gameState.puck.vy ** 2) / PUCK_RADIUS);
            const stepX = gameState.puck.vx / steps;
            const stepY = gameState.puck.vy / steps;
            
            for (let i = 0; i < steps; i++) {
                // Store previous position
                const prevX = gameState.puck.x;
                const prevY = gameState.puck.y;
                
                // Move one step
                gameState.puck.x += stepX;
                gameState.puck.y += stepY;
                
                // Check for wall nudging (very small push when touching walls)
                checkWallNudge();
                
                // Check if we're still in a valid position
                const currentRoom = gameState.puck.currentRoom;
                const room = rooms[currentRoom];
                
                if (room && !isPointInTunnel(gameState.puck.x, gameState.puck.y)) {
                    const cornerRadius = CONFIG.CORNER_RADIUS;
                    const left = room.x - room.width/2 + PUCK_RADIUS;
                    const right = room.x + room.width/2 - PUCK_RADIUS;
                    const top = room.y - room.height/2 + PUCK_RADIUS;
                    const bottom = room.y + room.height/2 - PUCK_RADIUS;
                    
                    let hitWall = false;
                    
                    // Basic rectangular bounds
                    if (gameState.puck.x < left || gameState.puck.x > right) {
                        gameState.puck.x = prevX;
                        gameState.puck.vx *= -CONFIG.WALL_BOUNCE;
                        hitWall = true;
                    }
                    
                    if (gameState.puck.y < top || gameState.puck.y > bottom) {
                        gameState.puck.y = prevY;
                        gameState.puck.vy *= -CONFIG.WALL_BOUNCE;
                        hitWall = true;
                    }
                    
                    // Check rounded corners
                    if (!hitWall) {
                        const corners = [
                            { x: left + cornerRadius, y: top + cornerRadius },    // Top-left
                            { x: right - cornerRadius, y: top + cornerRadius },   // Top-right
                            { x: left + cornerRadius, y: bottom - cornerRadius },  // Bottom-left
                            { x: right - cornerRadius, y: bottom - cornerRadius }  // Bottom-right
                        ];
                        
                        for (let j = 0; j < corners.length; j++) {
                            const corner = corners[j];
                            const inCornerX = (j % 2 === 0) ? gameState.puck.x < corner.x : gameState.puck.x > corner.x;
                            const inCornerY = (j < 2) ? gameState.puck.y < corner.y : gameState.puck.y > corner.y;
                            
                            if (inCornerX && inCornerY) {
                                const dist = distance(gameState.puck, corner);
                                if (dist > cornerRadius) {
                                    // Bounce off rounded corner
                                    const angle = Math.atan2(gameState.puck.y - corner.y, gameState.puck.x - corner.x);
                                    gameState.puck.x = corner.x + Math.cos(angle) * cornerRadius;
                                    gameState.puck.y = corner.y + Math.sin(angle) * cornerRadius;
                                    
                                    // Reflect velocity
                                    const normal = { x: Math.cos(angle), y: Math.sin(angle) };
                                    const dot = gameState.puck.vx * normal.x + gameState.puck.vy * normal.y;
                                    gameState.puck.vx -= 2 * dot * normal.x;
                                    gameState.puck.vy -= 2 * dot * normal.y;
                                    gameState.puck.vx *= CONFIG.WALL_BOUNCE;
                                    gameState.puck.vy *= CONFIG.WALL_BOUNCE;
                                    
                                    hitWall = true;
                                    break;
                                }
                            }
                        }
                    }
                    
                    if (hitWall) {
                        createBounceEffect(gameState.puck.x, gameState.puck.y);
                        break; // Stop moving this frame
                    }
                }
            }
            
            // Update puck's current room
            updatePuckRoom();
            
            // Check collisions with ALL characters
            for (let playerId = 1; playerId <= 3; playerId++) {
                for (let roomName in gameState.playerCharacters[playerId]) {
                    const character = gameState.playerCharacters[playerId][roomName];
                    
                    const dx = gameState.puck.x - character.x;
                    const dy = gameState.puck.y - character.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    // Magnet effect - pull puck closer and match player velocity
                    if (character.active && gameState.powerUps.playerEffects[playerId].magnet > 0 && distance < 120) {
                        const magnetForce = 0.35;
                        const dampingForce = 0.85; // Reduce puck velocity to prevent orbiting
                        
                        // Pull toward player
                        gameState.puck.vx -= (dx / distance) * magnetForce;
                        gameState.puck.vy -= (dy / distance) * magnetForce;
                        
                        // Add player's velocity to puck (so it follows player movement)
                        gameState.puck.vx += character.vx * 0.3;
                        gameState.puck.vy += character.vy * 0.3;
                        
                        // Apply damping to reduce excessive speed and orbiting
                        gameState.puck.vx *= dampingForce;
                        gameState.puck.vy *= dampingForce;
                    }
                    
                    if (distance < PUCK_RADIUS + PADDLE_RADIUS) {
                        const force = 0.3;
                        const normalX = dx / distance;
                        const normalY = dy / distance;
                        
                        // Softer bounce if magnet is active
                        const bounceFactor = gameState.powerUps.playerEffects[playerId].magnet > 0 ? 0.05 : 1;
                        
                        gameState.puck.vx += normalX * force * bounceFactor;
                        gameState.puck.vy += normalY * force * bounceFactor;
                        
                        const overlap = PUCK_RADIUS + PADDLE_RADIUS - distance;
                        gameState.puck.x += normalX * overlap;
                        gameState.puck.y += normalY * overlap;
                    }
                }
            }
            
            handlePuckBoundaries();
        }
        
        function updatePuckRoom() {
            // Don't update room during portal transition
            if (gameState.portalTransition.active) return;
            
            // Update cooldown
            if (gameState.portalTransition.cooldown > 0) {
                gameState.portalTransition.cooldown--;
            }
            
            gameState.puck.lastRoom = gameState.puck.currentRoom;
            
            // Check if puck is entering a tunnel/portal
            const currentRoom = rooms[gameState.puck.currentRoom];
            if (currentRoom && currentRoom.connections && gameState.portalTransition.cooldown === 0) {
                for (const [targetRoomName, tunnel] of Object.entries(currentRoom.connections)) {
                    const tunnelX = currentRoom.x + tunnel.x;
                    const tunnelY = currentRoom.y + tunnel.y;
                    
                    if (Math.abs(gameState.puck.x - tunnelX) <= tunnel.width/2 && 
                        Math.abs(gameState.puck.y - tunnelY) <= tunnel.height/2) {
                        // Puck entered a portal!
                        startPortalTransition(gameState.puck.currentRoom, targetRoomName);
                        return;
                    }
                }
            }
            
            // Normal room boundary checking
            for (const [roomName, room] of Object.entries(rooms)) {
                if (isPointInRoom(gameState.puck.x, gameState.puck.y, roomName)) {
                    if (gameState.puck.currentRoom !== roomName) {
                        gameState.puck.currentRoom = roomName;
                        gameState.currentRoom = roomName;
                        updateActiveCharacters();
                        updateRoomIndicator();
                    }
                    return;
                }
            }
            
            if (!isPointInTunnel(gameState.puck.x, gameState.puck.y)) {
                const room = rooms[gameState.puck.lastRoom];
                const left = room.x - room.width/2 + PUCK_RADIUS;
                const right = room.x + room.width/2 - PUCK_RADIUS;
                const top = room.y - room.height/2 + PUCK_RADIUS;
                const bottom = room.y + room.height/2 - PUCK_RADIUS;
                
                gameState.puck.x = Math.max(left, Math.min(right, gameState.puck.x));
                gameState.puck.y = Math.max(top, Math.min(bottom, gameState.puck.y));
            }
        }
        
        function startPortalTransition(fromRoom, toRoom) {
            const targetRoom = rooms[toRoom];
            const sourceRoom = rooms[fromRoom];
            
            // Find the matching tunnel in the target room
            let exitTunnel = null;
            for (const [connName, tunnel] of Object.entries(targetRoom.connections)) {
                if (connName === fromRoom) {
                    exitTunnel = tunnel;
                    break;
                }
            }
            
            if (!exitTunnel) return;
            
            // Calculate exit position - push puck away from portal to avoid re-entry
            const exitX = targetRoom.x + exitTunnel.x;
            const exitY = targetRoom.y + exitTunnel.y;
            
            // Calculate direction away from portal
            let pushX = 0, pushY = 0;
            const pushDistance = 80; // Distance to push puck from portal
            
            // Determine push direction based on which wall the portal is on
            if (Math.abs(exitTunnel.x) > Math.abs(exitTunnel.y)) {
                // Portal is on left/right wall
                pushX = exitTunnel.x > 0 ? -pushDistance : pushDistance;
            } else {
                // Portal is on top/bottom wall
                pushY = exitTunnel.y > 0 ? -pushDistance : pushDistance;
            }
            
            // Start the transition
            gameState.portalTransition = {
                active: true,
                startTime: Date.now(),
                duration: 400,
                fromRoom: fromRoom,
                toRoom: toRoom,
                fromPos: { x: gameState.puck.x, y: gameState.puck.y },
                toPos: { x: exitX + pushX, y: exitY + pushY },
                cooldown: 0 // Will be set when transition completes
            };
            
            // Preserve velocity direction but reduce magnitude during transition
            gameState.puck.vx *= 0.5;
            gameState.puck.vy *= 0.5;
        }
        
        function updatePortalTransition() {
            if (!gameState.portalTransition.active) return;
            
            const elapsed = Date.now() - gameState.portalTransition.startTime;
            const progress = Math.min(elapsed / gameState.portalTransition.duration, 1);
            
            if (progress >= 1) {
                // Transition complete
                gameState.puck.x = gameState.portalTransition.toPos.x;
                gameState.puck.y = gameState.portalTransition.toPos.y;
                gameState.puck.currentRoom = gameState.portalTransition.toRoom;
                gameState.currentRoom = gameState.portalTransition.toRoom;
                gameState.portalTransition.active = false;
                
                // Set cooldown to prevent immediate re-entry (about 1 second)
                gameState.portalTransition.cooldown = 60;
                
                updateActiveCharacters();
                updateRoomIndicator();
            }
        }
        
        function checkWallNudge() {
            const currentRoom = gameState.puck.currentRoom;
            const room = rooms[currentRoom];
            if (!room) return;
            
            const cornerRadius = CONFIG.CORNER_RADIUS;
            const left = room.x - room.width/2 + PUCK_RADIUS;
            const right = room.x + room.width/2 - PUCK_RADIUS;
            const top = room.y - room.height/2 + PUCK_RADIUS;
            const bottom = room.y + room.height/2 - PUCK_RADIUS;
            
            // Small nudge away from walls when very close
            const nudgeForce = 1; // 1 pixel push
            
            if (Math.abs(gameState.puck.x - left) < 2 && !isPointInTunnel(gameState.puck.x, gameState.puck.y)) {
                gameState.puck.x += nudgeForce;
            }
            if (Math.abs(gameState.puck.x - right) < 2 && !isPointInTunnel(gameState.puck.x, gameState.puck.y)) {
                gameState.puck.x -= nudgeForce;
            }
            if (Math.abs(gameState.puck.y - top) < 2 && !isPointInTunnel(gameState.puck.x, gameState.puck.y)) {
                gameState.puck.y += nudgeForce;
            }
            if (Math.abs(gameState.puck.y - bottom) < 2 && !isPointInTunnel(gameState.puck.x, gameState.puck.y)) {
                gameState.puck.y -= nudgeForce;
            }
        }
        
        function handlePuckBoundaries() {
            for (const [roomName, room] of Object.entries(rooms)) {
                if (isPointInRoom(gameState.puck.x, gameState.puck.y, roomName)) {
                    const left = room.x - room.width/2;
                    const right = room.x + room.width/2;
                    const top = room.y - room.height/2;
                    const bottom = room.y + room.height/2;
                    
                    if (gameState.puck.x - PUCK_RADIUS <= left) {
                        if (!hasTunnelAt(room, 'left', gameState.puck.y)) {
                            gameState.puck.vx = Math.abs(gameState.puck.vx) * 0.7;
                            gameState.puck.x = left + PUCK_RADIUS;
                        }
                    }
                    
                    if (gameState.puck.x + PUCK_RADIUS >= right) {
                        if (!hasTunnelAt(room, 'right', gameState.puck.y)) {
                            gameState.puck.vx = -Math.abs(gameState.puck.vx) * 0.7;
                            gameState.puck.x = right - PUCK_RADIUS;
                        }
                    }
                    
                    if (gameState.puck.y - PUCK_RADIUS <= top) {
                        if (!hasTunnelAt(room, 'top', gameState.puck.x)) {
                            gameState.puck.vy = Math.abs(gameState.puck.vy) * 0.7;
                            gameState.puck.y = top + PUCK_RADIUS;
                        }
                    }
                    
                    if (gameState.puck.y + PUCK_RADIUS >= bottom) {
                        if (!hasTunnelAt(room, 'bottom', gameState.puck.x)) {
                            gameState.puck.vy = -Math.abs(gameState.puck.vy) * 0.7;
                            gameState.puck.y = bottom - PUCK_RADIUS;
                        }
                    }
                    
                    break;
                }
            }
        }
        
        function hasTunnelAt(room, direction, coordinate) {
            if (!room.connections) return false;
            
            for (const [connectionName, tunnel] of Object.entries(room.connections)) {
                const tunnelX = room.x + tunnel.x;
                const tunnelY = room.y + tunnel.y;
                
                switch (direction) {
                    case 'left':
                    case 'right':
                        if (Math.abs(coordinate - tunnelY) <= tunnel.height/2) {
                            return true;
                        }
                        break;
                    case 'top':
                    case 'bottom':
                        if (Math.abs(coordinate - tunnelX) <= tunnel.width/2) {
                            return true;
                        }
                        break;
                }
            }
            return false;
        }
        
        function checkGoals() {
            for (const [roomName, room] of Object.entries(rooms)) {
                if (room.goals && isPointInRoom(gameState.puck.x, gameState.puck.y, roomName)) {
                    for (const goal of room.goals) {
                        let inGoal = false;
                        const goalX = room.x + goal.x;
                        const goalY = room.y + goal.y;
                        
                        switch (goal.direction) {
                            case 'top':
                                inGoal = gameState.puck.y <= goalY + 15 && 
                                        Math.abs(gameState.puck.x - goalX) <= GOAL_SIZE/2;
                                break;
                            case 'right':
                                inGoal = gameState.puck.x >= goalX - 15 && 
                                        Math.abs(gameState.puck.y - goalY) <= GOAL_SIZE/2;
                                break;
                            case 'bottom':
                                inGoal = gameState.puck.y >= goalY - 15 && 
                                        Math.abs(gameState.puck.x - goalX) <= GOAL_SIZE/2;
                                break;
                            case 'left':
                                inGoal = gameState.puck.x <= goalX + 15 && 
                                        Math.abs(gameState.puck.y - goalY) <= GOAL_SIZE/2;
                                break;
                        }
                        
                        if (inGoal) {
                            // Check if goal is protected by shield
                            if (gameState.powerUps.playerEffects[goal.owner].shield > 0) {
                                // Bounce the puck away instead of scoring
                                gameState.puck.vx *= -1;
                                gameState.puck.vy *= -1;
                                createBounceEffect(goalX, goalY);
                            } else {
                                // Normal scoring
                                for (let playerId = 1; playerId <= 3; playerId++) {
                                    if (playerId !== goal.owner) {
                                        gameState.playerScores[playerId]++;
                                    }
                                }
                                updateScoreDisplay();
                                
                                setTimeout(() => {
                                    gameState.puck.x = 0;
                                    gameState.puck.y = 0;
                                    gameState.puck.vx = (Math.random() - 0.5) * 4;
                                    gameState.puck.vy = (Math.random() - 0.5) * 4;
                                    gameState.puck.currentRoom = 'center';
                                    gameState.puck.trail = [];
                                    updateActiveCharacters();
                                }, 1000);
                            }
                            
                            return;
                        }
                    }
                }
            }
        }
        
        function updateScoreDisplay() {
            document.getElementById('score1').textContent = gameState.playerScores[1];
            document.getElementById('score2').textContent = gameState.playerScores[2];
            document.getElementById('score3').textContent = gameState.playerScores[3];
        }
        
        function updatePowerUpDisplay() {
            const icons = {
                magnet: 'ðŸ§²',
                speed: 'âš¡',
                shield: 'ðŸ›¡ï¸'
            };
            
            for (let playerId = 1; playerId <= 3; playerId++) {
                const effects = gameState.powerUps.playerEffects[playerId];
                const element = document.getElementById(`powerup${playerId}`);
                let display = '';
                
                // Check each effect
                for (let effect in effects) {
                    if (effects[effect] > 0) {
                        const seconds = Math.ceil(effects[effect] / 60);
                        display += `${icons[effect] || effect} ${seconds}s `;
                    }
                }
                
                // Slowdown is now a player effect
                if (effects.slowdown > 0) {
                    const seconds = Math.ceil(effects.slowdown / 60);
                    display += `ðŸŒ ${seconds}s `;
                }
                
                element.textContent = display.trim();
            }
        }
        
        function updateRoomIndicator() {
            const roomNames = {
                center: 'Center',
                player1_zone: 'Player 1 Zone',
                player2_zone: 'Player 2 Zone', 
                player3_zone: 'Player 3 Zone',
                frantic_zone: 'FRANTIC ZONE!'
            };
            document.getElementById('currentRoom').textContent = roomNames[gameState.currentRoom] || gameState.currentRoom;
        }
        
        // Enhanced rendering
        function render() {
            if (!gameConfig.gameStarted) return;
            
            const gradient = ctx.createRadialGradient(canvas.width/2, canvas.height/2, 0, canvas.width/2, canvas.height/2, Math.max(canvas.width, canvas.height)/2);
            gradient.addColorStop(0, '#0f0f23');
            gradient.addColorStop(1, '#0a0a0a');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            ctx.save();
            ctx.translate(-gameState.camera.x, -gameState.camera.y);
            
            drawRooms();
            drawTunnels();
            drawPowerUps();
            drawPuckTrail();
            drawAllCharacters();
            drawBounceEffects();   // Draw bounce effects after characters
            drawPuck();           // Draw puck LAST so it's always visible on top
            
            if (gameState.isPaused) {
                ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                ctx.fillRect(gameState.camera.x, gameState.camera.y, canvas.width, canvas.height);
                
                ctx.fillStyle = '#00ffff';
                ctx.font = '48px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('PAUSAD', gameState.camera.x + canvas.width/2, gameState.camera.y + canvas.height/2);
            }
            
            ctx.restore();
        }
        
        function drawRooms() {
            Object.entries(rooms).forEach(([roomName, room]) => {
                const cornerRadius = CONFIG.CORNER_RADIUS;
                const x = room.x - room.width/2;
                const y = room.y - room.height/2;
                const width = room.width;
                const height = room.height;
                
                // Draw room with rounded corners
                ctx.beginPath();
                ctx.moveTo(x + cornerRadius, y);
                ctx.lineTo(x + width - cornerRadius, y);
                ctx.quadraticCurveTo(x + width, y, x + width, y + cornerRadius);
                ctx.lineTo(x + width, y + height - cornerRadius);
                ctx.quadraticCurveTo(x + width, y + height, x + width - cornerRadius, y + height);
                ctx.lineTo(x + cornerRadius, y + height);
                ctx.quadraticCurveTo(x, y + height, x, y + height - cornerRadius);
                ctx.lineTo(x, y + cornerRadius);
                ctx.quadraticCurveTo(x, y, x + cornerRadius, y);
                ctx.closePath();
                
                // Fill with solid color
                ctx.fillStyle = room.color + '30'; // Semi-transparent solid color
                ctx.fill();
                
                // Stroke
                ctx.strokeStyle = room.type === 'frantic' ? '#ff00ff' : '#00ffff';
                ctx.lineWidth = room.type === 'frantic' ? 4 : 3;
                ctx.shadowColor = room.type === 'frantic' ? '#ff00ff' : '#00ffff';
                ctx.shadowBlur = room.type === 'frantic' ? 15 : 10;
                ctx.stroke();
                ctx.shadowBlur = 0;
                
                ctx.fillStyle = room.type === 'frantic' ? '#ff00ff' : '#ffffff';
                ctx.font = room.type === 'frantic' ? 'bold 18px Arial' : '16px Arial';
                ctx.textAlign = 'center';
                const roomDisplayName = room.type === 'frantic' ? 'FRANTIC ZONE!' : 
                                       room.type === 'defensive' ? `Player ${room.owner} Zone` : 
                                       'CENTER';
                ctx.fillText(roomDisplayName, room.x, room.y - room.height/2 + 25);
                
                if (room.goals) {
                    room.goals.forEach(goal => drawGoal(room, goal));
                }
            });
        }
        
        function drawGoal(room, goal) {
            // Skip drawing if owner has shield active
            if (gameState.powerUps.playerEffects[goal.owner].shield > 0) {
                return;
            }
            
            const goalX = room.x + goal.x;
            const goalY = room.y + goal.y;
            const goalColor = gameState.playerColors[goal.owner];
            
            ctx.strokeStyle = goalColor;
            ctx.fillStyle = goalColor + '50';
            ctx.lineWidth = 4;
            ctx.shadowColor = goalColor;
            ctx.shadowBlur = 15;
            
            let drawX, drawY, drawWidth, drawHeight;
            
            switch (goal.direction) {
                case 'top':
                    drawX = goalX - GOAL_SIZE/2;
                    drawY = goalY - 8;
                    drawWidth = GOAL_SIZE;
                    drawHeight = 16;
                    break;
                case 'right':
                    drawX = goalX - 8;
                    drawY = goalY - GOAL_SIZE/2;
                    drawWidth = 16;
                    drawHeight = GOAL_SIZE;
                    break;
                case 'bottom':
                    drawX = goalX - GOAL_SIZE/2;
                    drawY = goalY - 8;
                    drawWidth = GOAL_SIZE;
                    drawHeight = 16;
                    break;
                case 'left':
                    drawX = goalX - 8;
                    drawY = goalY - GOAL_SIZE/2;
                    drawWidth = 16;
                    drawHeight = GOAL_SIZE;
                    break;
            }
            
            ctx.fillRect(drawX, drawY, drawWidth, drawHeight);
            ctx.strokeRect(drawX, drawY, drawWidth, drawHeight);
            
            ctx.fillStyle = '#ffffff';
            ctx.font = 'bold 14px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(goal.owner, goalX, goalY + 5);
            
            ctx.shadowBlur = 0;
        }
        
        function drawTunnels() {
            Object.entries(rooms).forEach(([roomName, room]) => {
                Object.entries(room.connections || {}).forEach(([connectionName, tunnel]) => {
                    const tunnelCenterX = room.x + tunnel.x;
                    const tunnelCenterY = room.y + tunnel.y;
                    const tunnelX = tunnelCenterX - tunnel.width/2;
                    const tunnelY = tunnelCenterY - tunnel.height/2;
                    
                    // Portal glow effect
                    const glowSize = 40 + Math.sin(gameState.gameTime * 0.05) * 10;
                    const gradient = ctx.createRadialGradient(tunnelCenterX, tunnelCenterY, 0, tunnelCenterX, tunnelCenterY, glowSize);
                    gradient.addColorStop(0, 'rgba(0, 255, 255, 0.8)');
                    gradient.addColorStop(0.5, 'rgba(0, 128, 255, 0.4)');
                    gradient.addColorStop(1, 'rgba(0, 255, 255, 0)');
                    
                    ctx.fillStyle = gradient;
                    ctx.fillRect(tunnelCenterX - glowSize, tunnelCenterY - glowSize, glowSize * 2, glowSize * 2);
                    
                    // Portal core
                    ctx.fillStyle = '#001133';
                    ctx.fillRect(tunnelX, tunnelY, tunnel.width, tunnel.height);
                    
                    // Portal swirl effect
                    ctx.save();
                    ctx.translate(tunnelCenterX, tunnelCenterY);
                    ctx.rotate(gameState.gameTime * 0.04);
                    
                    // Inner spiral
                    ctx.strokeStyle = 'rgba(0, 255, 255, 0.6)';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    for (let i = 0; i < 20; i++) {
                        const angle = i * 0.3;
                        const radius = i * 1.5;
                        const x = Math.cos(angle) * radius;
                        const y = Math.sin(angle) * radius;
                        if (i === 0) ctx.moveTo(x, y);
                        else ctx.lineTo(x, y);
                    }
                    ctx.stroke();
                    
                    ctx.restore();
                    
                    // Portal border
                    ctx.strokeStyle = '#00ffff';
                    ctx.lineWidth = 3;
                    ctx.shadowColor = '#00ffff';
                    ctx.shadowBlur = 15;
                    ctx.strokeRect(tunnelX, tunnelY, tunnel.width, tunnel.height);
                    ctx.shadowBlur = 0;
                });
            });
        }
        
        function drawPowerUps() {
            gameState.powerUps.spawned.forEach(powerUp => {
                if (powerUp.room !== gameState.currentRoom) return;
                
                ctx.save();
                ctx.translate(powerUp.x, powerUp.y);
                ctx.rotate(powerUp.rotation);
                
                // Pulsing effect
                const pulseScale = 1 + Math.sin(powerUp.pulsePhase) * 0.2;
                ctx.scale(pulseScale, pulseScale);
                
                // Box background
                const size = CONFIG.POWERUP_SIZE;
                ctx.fillStyle = '#001144';
                ctx.strokeStyle = '#00ffff';
                ctx.lineWidth = 3;
                ctx.shadowColor = '#00ffff';
                ctx.shadowBlur = 15;
                
                // Draw box
                ctx.fillRect(-size, -size, size * 2, size * 2);
                ctx.strokeRect(-size, -size, size * 2, size * 2);
                
                // Draw icon based on type
                ctx.fillStyle = '#ffffff';
                ctx.font = 'bold 20px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                
                const icons = {
                    magnet: 'ðŸ§²',
                    speed: 'âš¡',
                    slowdown: 'ðŸŒ',
                    shield: 'ðŸ›¡ï¸'
                };
                
                ctx.fillText(icons[powerUp.type] || '?', 0, 0);
                
                ctx.restore();
            });
        }
        
        function drawPuckTrail() {
            ctx.globalAlpha = 0.6;
            gameState.puck.trail.forEach((point, index) => {
                const alpha = index / gameState.puck.trail.length;
                const radius = PUCK_RADIUS * alpha * 0.7;
                
                ctx.fillStyle = `rgba(255, 255, 255, ${alpha * 0.5})`;
                ctx.beginPath();
                ctx.arc(point.x, point.y, radius, 0, Math.PI * 2);
                ctx.fill();
            });
            ctx.globalAlpha = 1;
        }
        
        function drawAllCharacters() {
            for (let playerId = 1; playerId <= 3; playerId++) {
                const playerColor = gameState.playerColors[playerId];
                
                for (let roomName in gameState.playerCharacters[playerId]) {
                    const character = gameState.playerCharacters[playerId][roomName];
                    drawCharacter(character, playerId, playerColor, character.active);
                }
            }
        }
        
        function drawCharacter(character, playerId, color, isActive) {
            const alpha = isActive ? 1.0 : 0.25;
            const isAI = gameState.playerTypes[playerId] === 'ai';
            const isKicking = character.kickEffect > 0;
            
            // Calculate tilt based on velocity
            const vx = character.vx || 0;
            const vy = character.vy || 0;
            const speed = Math.sqrt(vx * vx + vy * vy);
            const maxTilt = 0.4; // Maximum tilt amount (increased slightly)
            const tiltX = (vx / CONFIG.PLAYER_SPEED) * maxTilt;
            const tiltY = (vy / CONFIG.PLAYER_SPEED) * maxTilt;
            
            // Dynamic shadow based on movement direction
            ctx.save();
            ctx.globalAlpha = alpha * 0.6; // More opaque shadow
            ctx.fillStyle = 'rgba(0, 0, 0, 0.8)'; // Darker shadow
            
            // Shadow moves opposite to movement direction (tilt effect)
            const baseShadowOffset = 8;
            const shadowOffsetX = baseShadowOffset - tiltX * 20; // Shadow opposite to tilt
            const shadowOffsetY = baseShadowOffset - tiltY * 20;
            
            // Shadow stretches more when moving faster
            const shadowScaleX = 1.1 + Math.abs(tiltY) * 0.2; // Stretch perpendicular to movement
            const shadowScaleY = 1.1 + Math.abs(tiltX) * 0.2;
            
            ctx.translate(character.x + shadowOffsetX, character.y + shadowOffsetY);
            ctx.scale(shadowScaleX, shadowScaleY);
            ctx.beginPath();
            ctx.arc(0, 0, PADDLE_RADIUS * 0.9, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();
            
            // Draw subtle movement trail if moving fast
            if (isActive && (Math.abs(character.vx) > 2 || Math.abs(character.vy) > 2)) {
                const tailLength = 12;
                const tailSteps = 2;
                
                for (let i = 0; i < tailSteps; i++) {
                    const t = (i + 1) / tailSteps;
                    const tailX = character.x - character.vx * t * tailLength;
                    const tailY = character.y - character.vy * t * tailLength;
                    const tailRadius = PADDLE_RADIUS * (1 - t * 0.3);
                    
                    ctx.fillStyle = color;
                    ctx.globalAlpha = alpha * 0.2 * (1 - t);
                    ctx.beginPath();
                    ctx.arc(tailX, tailY, tailRadius, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
            
            ctx.globalAlpha = alpha;
            
            // Enhanced visuals when kicking
            const paddleRadius = isKicking ? PADDLE_RADIUS + 5 : PADDLE_RADIUS;
            
            // Calculate subtle squash effect based on movement (speed already calculated above)
            const squashAmount = Math.min(speed / 20, 0.15); // Max 15% squash, more subtle
            
            ctx.fillStyle = color;
            ctx.strokeStyle = color;
            ctx.lineWidth = isActive ? 4 : 2;
            // Removed glow effect (shadowBlur) for cleaner look
            
            ctx.save();
            ctx.translate(character.x, character.y);
            
            // Apply tilt and squash effect based on movement
            if (speed > 0.1) {
                // Apply 3D tilt effect
                const scaleX = 1 - Math.abs(tiltX) * 0.3;
                const scaleY = 1 - Math.abs(tiltY) * 0.3;
                const skewX = tiltX * 0.2;
                const skewY = tiltY * 0.2;
                
                // Create transformation matrix for tilted disk effect
                ctx.transform(scaleX, skewY, skewX, scaleY, 0, 0);
                
                // Add slight rotation based on movement direction
                const angle = Math.atan2(vy, vx);
                ctx.rotate(angle * 0.1);
            }
            
            // Draw the main character shape
            ctx.beginPath();
            ctx.arc(0, 0, paddleRadius, 0, Math.PI * 2);
            
            // Gradient fill for 3D effect
            const gradient = ctx.createRadialGradient(-paddleRadius * 0.3 * tiltX, -paddleRadius * 0.3 * tiltY, 0, 0, 0, paddleRadius);
            gradient.addColorStop(0, color);
            gradient.addColorStop(0.7, color);
            gradient.addColorStop(1, adjustBrightness(color, -30));
            ctx.fillStyle = gradient;
            ctx.fill();
            
            ctx.stroke();
            
            ctx.restore();
            
            // Draw power-up effects
            if (isActive) {
                const effects = gameState.powerUps.playerEffects[playerId];
                
                // Magnet effect
                if (effects.magnet > 0) {
                    ctx.strokeStyle = '#ff00ff';
                    ctx.lineWidth = 3;
                    ctx.globalAlpha = 0.6 + Math.sin(gameState.gameTime * 0.08) * 0.3;
                    ctx.beginPath();
                    ctx.arc(character.x, character.y, 80, 0, Math.PI * 2);
                    ctx.stroke();
                    
                    // Add inner ring for stronger visual
                    ctx.lineWidth = 2;
                    ctx.globalAlpha = 0.4 + Math.sin(gameState.gameTime * 0.12) * 0.2;
                    ctx.beginPath();
                    ctx.arc(character.x, character.y, 50, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.globalAlpha = 1;
                }
                
                // Speed effect
                if (effects.speed > 0) {
                    ctx.strokeStyle = '#ffff00';
                    ctx.lineWidth = 3;
                    ctx.globalAlpha = 0.6;
                    const sparkles = 3;
                    for (let i = 0; i < sparkles; i++) {
                        const angle = (gameState.gameTime * 0.1 + i * Math.PI * 2 / sparkles) % (Math.PI * 2);
                        const x = character.x + Math.cos(angle) * 35;
                        const y = character.y + Math.sin(angle) * 35;
                        ctx.beginPath();
                        ctx.moveTo(x - 5, y);
                        ctx.lineTo(x + 5, y);
                        ctx.moveTo(x, y - 5);
                        ctx.lineTo(x, y + 5);
                        ctx.stroke();
                    }
                    ctx.globalAlpha = 1;
                }
                
                // Shield effect
                if (effects.shield > 0) {
                    ctx.strokeStyle = '#00ff00';
                    ctx.fillStyle = 'rgba(0, 255, 0, 0.1)';
                    ctx.lineWidth = 3;
                    ctx.globalAlpha = 0.7 + Math.sin(gameState.gameTime * 0.05) * 0.3;
                    ctx.beginPath();
                    ctx.arc(character.x, character.y, PADDLE_RADIUS + 10, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.stroke();
                    ctx.globalAlpha = 1;
                }
            }
            
            // Player number removed for cleaner look
            
            // AI indicator
            if (isAI && isActive) {
                ctx.fillStyle = '#ffff00';
                ctx.font = '10px Arial';
                ctx.fillText('AI', character.x, character.y - PADDLE_RADIUS - 8);
            }
            
            // Kick indicator
            if (isActive && isKicking) {
                ctx.fillStyle = '#ffffff';
                ctx.font = 'bold 12px Arial';
                ctx.fillText('KICK!', character.x, character.y - PADDLE_RADIUS - 20);
            }
            
            // Can kick indicator (when close to puck)
            if (isActive && !isAI && gameState.kickCooldowns[playerId] === 0) {
                const dist = distance(character, gameState.puck);
                if (dist <= KICK_RANGE) {
                    ctx.strokeStyle = '#ffff00';
                    ctx.lineWidth = 2;
                    ctx.setLineDash([3, 3]);
                    ctx.beginPath();
                    ctx.arc(character.x, character.y, KICK_RANGE, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.setLineDash([]);
                }
            }
            
            
            ctx.globalAlpha = 1;
        }
        
        function drawPuck() {
            // Force reset all context state to ensure puck is visible
            ctx.save();
            
            // Special effect during portal transition
            if (gameState.portalTransition.active) {
                const elapsed = Date.now() - gameState.portalTransition.startTime;
                const progress = elapsed / gameState.portalTransition.duration;
                
                // Fade out/in effect
                ctx.globalAlpha = progress < 0.5 ? 1 - (progress * 2) : (progress - 0.5) * 2;
                
                // Portal energy effect around puck
                const energyRadius = 30 + Math.sin(elapsed * 0.01) * 10;
                const gradient = ctx.createRadialGradient(gameState.puck.x, gameState.puck.y, 0, gameState.puck.x, gameState.puck.y, energyRadius);
                gradient.addColorStop(0, 'rgba(0, 255, 255, 0.8)');
                gradient.addColorStop(0.5, 'rgba(255, 255, 255, 0.4)');
                gradient.addColorStop(1, 'rgba(0, 255, 255, 0)');
                ctx.fillStyle = gradient;
                ctx.fillRect(gameState.puck.x - energyRadius, gameState.puck.y - energyRadius, energyRadius * 2, energyRadius * 2);
            } else {
                ctx.globalAlpha = 1.0;
            }
            
            ctx.shadowColor = 'transparent';
            ctx.shadowBlur = 0;
            
            // Puck shadow
            ctx.fillStyle = 'rgba(0, 0, 0, 0.4)';
            ctx.beginPath();
            ctx.arc(gameState.puck.x + 2, gameState.puck.y + 2, PUCK_RADIUS, 0, Math.PI * 2);
            ctx.fill();
            
            // Main puck with rotation
            const rotation = gameState.gameTime * 0.1;
            ctx.translate(gameState.puck.x, gameState.puck.y);
            ctx.rotate(rotation);
            
            // Puck body - VERY bright and visible
            ctx.fillStyle = '#ffffff';
            ctx.strokeStyle = '#00ffff';
            ctx.lineWidth = 4;
            
            // Strong glow effect
            ctx.shadowColor = '#ffffff';
            ctx.shadowBlur = 15;
            
            ctx.beginPath();
            ctx.arc(0, 0, PUCK_RADIUS, 0, Math.PI * 2);
            ctx.fill();
            
            // Reset shadow for stroke
            ctx.shadowColor = 'transparent';
            ctx.shadowBlur = 0;
            ctx.stroke();
            
            // Puck cross pattern - make it more visible
            ctx.strokeStyle = '#00dddd';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(-PUCK_RADIUS * 0.7, 0);
            ctx.lineTo(PUCK_RADIUS * 0.7, 0);
            ctx.moveTo(0, -PUCK_RADIUS * 0.7);
            ctx.lineTo(0, PUCK_RADIUS * 0.7);
            ctx.stroke();
            
            // Restore context
            ctx.restore();
        }
        
        // Game loop
        function gameLoop() {
            update();
            render();
            requestAnimationFrame(gameLoop);
        }
        
        // Initialize everything
        initMenu();
        updatePlayerTypes();
        gameLoop();
    </script>
</body>
</html>