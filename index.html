<!DOCTYPE html>
<html lang="sv">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Projectyle Remake - AI Edition</title>
    <style>
body {
    margin: 0;
    padding: 0;
    background: linear-gradient(135deg, #0a0a0a, #1a1a2e);
    display: flex;
    justify-content: center;
    align-items: center;
    min-height: 100vh;
    font-family: 'Orbitron', 'Arial', sans-serif;
    color: #00ffff;
    overflow: hidden;
}

#gameContainer {
    position: relative;
    border: 3px solid #00ffff;
    border-radius: 15px;
    box-shadow: 0 0 30px #00ffff, inset 0 0 20px rgba(0, 255, 255, 0.1);
    overflow: hidden;
    background: linear-gradient(45deg, #0a0a0a, #0f0f23);
}

#gameCanvas {
    display: block;
    background: radial-gradient(circle at center, #0f0f23 0%, #0a0a0a 100%);
}

#startMenu {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0, 0, 0, 0.9);
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    z-index: 100;
}

#startMenu h1 {
    font-size: 48px;
    margin-bottom: 40px;
    text-shadow: 0 0 20px #00ffff;
}

.menu-section {
    margin: 20px 0;
    text-align: center;
}

.menu-section h3 {
    margin-bottom: 15px;
    color: #ffff00;
}

.menu-buttons {
    display: flex;
    gap: 15px;
    justify-content: center;
    flex-wrap: wrap;
}

.menu-button {
    padding: 15px 25px;
    background: linear-gradient(135deg, #1a1a2e, #16213e);
    border: 2px solid #00ffff;
    border-radius: 10px;
    color: #00ffff;
    cursor: pointer;
    font-family: inherit;
    font-size: 16px;
    transition: all 0.3s;
}

.menu-button:hover {
    background: linear-gradient(135deg, #16213e, #1a1a2e);
    box-shadow: 0 0 15px rgba(0, 255, 255, 0.5);
    transform: translateY(-2px);
}

.menu-button.selected {
    background: linear-gradient(135deg, #004444, #006666);
    box-shadow: 0 0 20px rgba(0, 255, 255, 0.7);
}

#startButton {
    margin-top: 30px;
    padding: 20px 40px;
    font-size: 24px;
    background: linear-gradient(135deg, #006600, #008800);
    border: 3px solid #00ff00;
    color: #00ff00;
}

#startButton:hover {
    background: linear-gradient(135deg, #008800, #00aa00);
    box-shadow: 0 0 25px rgba(0, 255, 0, 0.7);
}

#ui {
    position: absolute;
    top: 15px;
    left: 15px;
    z-index: 10;
    background: linear-gradient(135deg, rgba(0, 0, 0, 0.8), rgba(26, 26, 46, 0.8));
    padding: 15px;
    border-radius: 10px;
}

#controls {
    position: absolute;
    bottom: 15px;
    left: 15px;
    right: 15px;
    z-index: 10;
    background: linear-gradient(135deg, rgba(0, 0, 0, 0.8), rgba(26, 26, 46, 0.8));
    padding: 15px;
    border-radius: 10px;
    border: 2px solid #00ffff;
    text-align: center;
    font-size: 14px;
    box-shadow: 0 0 15px rgba(0, 255, 255, 0.3);
}

.score {
    margin: 8px 0;
    font-weight: bold;
    font-size: 16px;
    text-shadow: 0 0 10px currentColor;
}

.player1 { color: #ff0080; }
.player2 { color: #80ff00; }
.player3 { color: #ff8000; }

.ai-indicator {
    font-size: 12px;
    opacity: 0.8;
}

.room-indicator {
    position: absolute;
    top: 80px;
    left: 15px;
    background: rgba(0, 0, 0, 0.7);
    padding: 8px 12px;
    border-radius: 5px;
    border: 1px solid #00ffff;
    font-size: 12px;
}

.active-player {
    position: absolute;
    top: 120px;
    left: 15px;
    background: rgba(0, 0, 0, 0.7);
    padding: 8px 12px;
    border-radius: 5px;
    border: 1px solid #ffff00;
    font-size: 12px;
    color: #ffff00;
}

.powerup-display {
    font-size: 16px;
    font-weight: bold;
    opacity: 1;
}
</style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="gameCanvas" width="1600" height="1200"></canvas>
        
        <div id="startMenu">
            <h1>üéÆ PROJECTYLE</h1>
            
            <div class="menu-section">
                <h3>Antal M√§nskliga Spelare</h3>
                <div class="menu-buttons">
                    <button class="menu-button selected" data-humans="1">1 Spelare</button>
                    <button class="menu-button" data-humans="2">2 Spelare</button>
                    <button class="menu-button" data-humans="3">3 Spelare</button>
                </div>
            </div>
            
            <div class="menu-section">
                <h3>AI Intelligens</h3>
                <div class="menu-buttons">
                    <button class="menu-button" data-difficulty="easy">Dum</button>
                    <button class="menu-button selected" data-difficulty="medium">Meh</button>
                    <button class="menu-button" data-difficulty="hard">Genial</button>
                </div>
            </div>
            
            <button id="startButton" class="menu-button">STARTA SPEL</button>
            
            <div class="menu-section" style="margin-top: 40px;">
                <h3>Kontroller</h3>
                <div style="text-align: left; max-width: 600px; margin: 0 auto; font-size: 14px; color: #00ffff;">
                    <div style="margin: 10px 0;">
                        <span style="color: #ff0080;">üî¥ Spelare 1:</span> Piltangenter f√∂r r√∂relse + Mellanslag f√∂r spark
                    </div>
                    <div style="margin: 10px 0;">
                        <span style="color: #80ff00;">üü¢ Spelare 2:</span> WASD f√∂r r√∂relse + V√§nster Shift f√∂r spark
                    </div>
                    <div style="margin: 10px 0;">
                        <span style="color: #ff8000;">üü† Spelare 3:</span> IJKL f√∂r r√∂relse + H f√∂r spark
                    </div>
                    <div style="margin-top: 20px; color: #ffff00;">
                        ‚ö° <strong>Tips:</strong> St√• n√§ra bollen och sparka f√∂r extra kraft!<br>
                        üéØ <strong>M√•l:</strong> G√∂ra m√•l i motst√•ndarnas m√•l!<br>
                        üåÄ <strong>Portaler:</strong> Anv√§nd portalerna f√∂r att f√∂rflytta dig mellan rum!
                    </div>
                    <div style="margin-top: 20px; opacity: 0.7;">
                        R = Starta om | ESC = Paus | M = Tillbaka till meny
                    </div>
                </div>
            </div>
        </div>
        
        <div id="ui">
            <div class="score player1">
                üî¥ Spelare 1: <span id="score1">0</span> <span id="ai1" class="ai-indicator"></span> <span id="powerup1" class="powerup-display"></span>
            </div>
            <div class="score player2">
                üü¢ Spelare 2: <span id="score2">0</span> <span id="ai2" class="ai-indicator"></span> <span id="powerup2" class="powerup-display"></span>
            </div>
            <div class="score player3">
                üü† Spelare 3: <span id="score3">0</span> <span id="ai3" class="ai-indicator"></span> <span id="powerup3" class="powerup-display"></span>
            </div>
        </div>
        
        <div class="room-indicator" id="roomIndicator">Rum: CENTER</div>
        <div class="active-player" id="activePlayerDisplay" style="display: none;">Du √§r: Spelare 1</div>
        
        <div id="controls">
            <strong>üéÆ PROJECTYLE</strong> | 
            AI: <span id="difficultyDisplay">Smart</span> | 
            Puck: <span id="puckPosition">0,0</span> | 
            <span id="currentRoom">Center</span> | 
            <span id="activePlayers">Center</span> | 
            <em style="opacity: 0.7;">R = Restart | ESC = Paus | M = Meny</em>
        </div>
    </div>

    <script>

// ========== config.js ==========
// Game Configuration
const CONFIG = {
    // Room settings
    ROOM_SIZE: 1000,
    ROOM_SPACING: 1.5,
    CORNER_RADIUS: 50,
    
    // Object sizes
    PUCK_RADIUS: 12,     // Increased from 10 to 12
    PADDLE_RADIUS: 30,   // Increased from 25 to 30
    GOAL_SIZE: 100,
    TUNNEL_WIDTH: 72,    // Increased 20% from 60 to 72
    
    // Physics settings
    PLAYER_SPEED: 5.5,   // Base player movement speed
    MAX_PUCK_SPEED: 10,  // Maximum puck velocity
    FRICTION: 0.98,      // Puck friction (lower = more friction)
    WALL_BOUNCE: 0.77,   // Wall bounce dampening
    KICK_RANGE: 50,
    KICK_FORCE: 8.5,     // Base kick strength
    
    // Visual settings
    TRAIL_LENGTH: 8,
    BOUNCE_EFFECT_DURATION: 15,
    PORTAL_TRANSITION_DURATION: 400,
    PORTAL_COOLDOWN: 60,
    PORTAL_PUSH_DISTANCE: 80,
    
    // AI settings
    STUCK_THRESHOLD: 30,
    STUCK_RESET: 60,
    ANTI_STUCK_FORCE: 2,
    
    // Power-up settings
    POWERUP_SPAWN_CHANCE: 0.0008,  // Spawn probability per frame
    POWERUP_SIZE: 20,
    POWERUP_LIFETIME: 600,     // 10 seconds before disappearing
    POWERUP_DURATION: {
        magnet: 300,      // 5 seconds
        speed: 300,       // 5 seconds
        slowdown: 300,    // 5 seconds
        shield: 300       // 5 seconds
    }
};

// AI difficulty settings
const AI_SETTINGS = {
    easy: {
        reactionTime: 25,        // Slower decision making
        accuracy: 0.4,           // Poor aim
        strategy: 0.2,           // Mostly just follows ball
        predictionFrames: 0      // No prediction
    },
    medium: {
        reactionTime: 15,        // Normal decision making
        accuracy: 0.7,           // Decent aim
        strategy: 0.6,           // Some strategic thinking
        predictionFrames: 3      // Short prediction
    },
    hard: {
        reactionTime: 8,         // Quick decision making  
        accuracy: 0.9,           // Excellent aim
        strategy: 0.85,          // Very strategic
        predictionFrames: 6      // Good prediction
    }
};

// Player colors
const PLAYER_COLORS = {
    1: '#ff0080',
    2: '#80ff00',
    3: '#ff8000'
};

// Power-up types and icons
const POWERUP_TYPES = {
    magnet: { icon: 'üß≤', color: '#ff00ff' },
    speed: { icon: '‚ö°', color: '#ffff00' },
    slowdown: { icon: 'üêå', color: '#00ffff' },
    shield: { icon: 'üõ°Ô∏è', color: '#00ff00' }
};
// ========== utils.js ==========
// Utility functions

function distance(a, b) {
    return Math.sqrt((a.x - b.x) ** 2 + (a.y - b.y) ** 2);
}

function adjustBrightness(color, amount) {
    // Convert hex to RGB
    const hex = color.replace('#', '');
    const r = parseInt(hex.substr(0, 2), 16);
    const g = parseInt(hex.substr(2, 2), 16);
    const b = parseInt(hex.substr(4, 2), 16);
    
    // Adjust brightness
    const newR = Math.max(0, Math.min(255, r + amount));
    const newG = Math.max(0, Math.min(255, g + amount));
    const newB = Math.max(0, Math.min(255, b + amount));
    
    // Convert back to hex
    return '#' + ((1 << 24) + (newR << 16) + (newG << 8) + newB).toString(16).slice(1);
}

function clamp(value, min, max) {
    return Math.max(min, Math.min(max, value));
}

function randomRange(min, max) {
    return Math.random() * (max - min) + min;
}

function normalizeVector(vector) {
    const magnitude = Math.sqrt(vector.x * vector.x + vector.y * vector.y);
    if (magnitude === 0) return { x: 0, y: 0 };
    return {
        x: vector.x / magnitude,
        y: vector.y / magnitude
    };
}

function dotProduct(a, b) {
    return a.x * b.x + a.y * b.y;
}

function lerp(start, end, t) {
    return start + (end - start) * t;
}

function angleToVector(angle) {
    return {
        x: Math.cos(angle),
        y: Math.sin(angle)
    };
}

function vectorToAngle(vector) {
    return Math.atan2(vector.y, vector.x);
}
// ========== gameState.js ==========
// Room definitions
const rooms = {
    center: { 
        x: 0, y: 0, 
        width: CONFIG.ROOM_SIZE, height: CONFIG.ROOM_SIZE,
        connections: {
            player1_zone: { x: 0, y: -CONFIG.ROOM_SIZE/2, width: CONFIG.TUNNEL_WIDTH, height: CONFIG.TUNNEL_WIDTH },
            player2_zone: { x: CONFIG.ROOM_SIZE/2, y: 0, width: CONFIG.TUNNEL_WIDTH, height: CONFIG.TUNNEL_WIDTH },
            player3_zone: { x: -CONFIG.ROOM_SIZE/2, y: 0, width: CONFIG.TUNNEL_WIDTH, height: CONFIG.TUNNEL_WIDTH },
            frantic_zone: { x: 0, y: CONFIG.ROOM_SIZE/2, width: CONFIG.TUNNEL_WIDTH, height: CONFIG.TUNNEL_WIDTH }
        },
        color: '#00ff44',
        type: 'center'
    },
    player1_zone: { 
        x: 0, y: -CONFIG.ROOM_SIZE * CONFIG.ROOM_SPACING, 
        width: CONFIG.ROOM_SIZE, height: CONFIG.ROOM_SIZE,
        connections: {
            center: { x: 0, y: CONFIG.ROOM_SIZE/2, width: CONFIG.TUNNEL_WIDTH, height: CONFIG.TUNNEL_WIDTH }
        },
        color: '#44ff44',
        type: 'defensive',
        owner: 1,
        goalColor: '#ff0080',
        goals: [{ x: 0, y: -CONFIG.ROOM_SIZE/2 + 2, direction: 'top', owner: 1 }]
    },
    player2_zone: { 
        x: CONFIG.ROOM_SIZE * CONFIG.ROOM_SPACING, y: 0, 
        width: CONFIG.ROOM_SIZE, height: CONFIG.ROOM_SIZE,
        connections: {
            center: { x: -CONFIG.ROOM_SIZE/2, y: 0, width: CONFIG.TUNNEL_WIDTH, height: CONFIG.TUNNEL_WIDTH }
        },
        color: '#00ff00',
        type: 'defensive',
        owner: 2,
        goalColor: '#80ff00',
        goals: [{ x: CONFIG.ROOM_SIZE/2 - 2, y: 0, direction: 'right', owner: 2 }]
    },
    player3_zone: { 
        x: -CONFIG.ROOM_SIZE * CONFIG.ROOM_SPACING, y: 0, 
        width: CONFIG.ROOM_SIZE, height: CONFIG.ROOM_SIZE,
        connections: {
            center: { x: CONFIG.ROOM_SIZE/2, y: 0, width: CONFIG.TUNNEL_WIDTH, height: CONFIG.TUNNEL_WIDTH }
        },
        color: '#44ff00',
        type: 'defensive',
        owner: 3,
        goalColor: '#ff8000',
        goals: [{ x: -CONFIG.ROOM_SIZE/2 + 2, y: 0, direction: 'left', owner: 3 }]
    },
    frantic_zone: { 
        x: 0, y: CONFIG.ROOM_SIZE * CONFIG.ROOM_SPACING, 
        width: CONFIG.ROOM_SIZE, height: CONFIG.ROOM_SIZE,
        connections: {
            center: { x: 0, y: -CONFIG.ROOM_SIZE/2, width: CONFIG.TUNNEL_WIDTH, height: CONFIG.TUNNEL_WIDTH }
        },
        color: '#22ff22',
        type: 'frantic',
        goals: [
            { x: -CONFIG.ROOM_SIZE/2, y: 0, direction: 'left', owner: 1 },
            { x: CONFIG.ROOM_SIZE/2, y: 0, direction: 'right', owner: 2 },
            { x: 0, y: CONFIG.ROOM_SIZE/2 - 2, direction: 'bottom', owner: 3 }
        ]
    }
};

// Game state
const gameState = {
    gameTime: 0,
    isPaused: false,
    camera: { x: 0, y: 0 },
    puck: { 
        x: 0, y: 0, z: 0,
        vx: 0, vy: 0, vz: 0,
        currentRoom: 'center',
        trail: [],
        gravity: 0.3
    },
    playerScores: { 1: 0, 2: 0, 3: 0 },
    playerTypes: { 1: 'human', 2: 'ai', 3: 'ai' },
    playerColors: { 1: '#ff0080', 2: '#80ff00', 3: '#ff8000' },
    playerCharacters: {
        1: {},
        2: {},
        3: {}
    },
    kickCooldowns: { 1: 0, 2: 0, 3: 0 },
    keys: {},
    bounceEffects: [],
    currentRoom: 'center',
    aiState: {
        1: { lastDecision: 0, target: null, strategy: 'follow', stuckCounter: 0, lastPos: {x: 0, y: 0} },
        2: { lastDecision: 0, target: null, strategy: 'follow', stuckCounter: 0, lastPos: {x: 0, y: 0} },
        3: { lastDecision: 0, target: null, strategy: 'follow', stuckCounter: 0, lastPos: {x: 0, y: 0} }
    },
    portalTransition: {
        active: false,
        progress: 0,
        duration: CONFIG.PORTAL_TRANSITION_DURATION,
        fromPos: { x: 0, y: 0 },
        toPos: { x: 0, y: 0 },
        cooldown: 0
    },
    powerUps: {
        spawned: [],
        playerEffects: {
            1: { magnet: 0, speed: 0, shield: 0, slowdown: 0 },
            2: { magnet: 0, speed: 0, shield: 0, slowdown: 0 },
            3: { magnet: 0, speed: 0, shield: 0, slowdown: 0 }
        },
        globalEffects: { slowdown: 0 }
    },
    faceOff: {
        active: false,
        countdown: 0,
        room: 'center',
        position: { x: 0, y: 0 }
    },
    puckStuck: {
        position: { x: 0, y: 0 },
        timer: 0,
        threshold: 5,
        timeLimit: 180
    }
};

// Add missing properties to gameState
gameState.gameStarted = false;
gameState.humanPlayers = 1;
gameState.aiPlayers = 2;
gameState.aiDifficulty = 'medium';

// Game configuration
const gameConfig = {
    humanPlayers: 1,
    aiPlayers: 2,
    aiDifficulty: 'medium',
    gameStarted: false
};

// Initialize character positions for all rooms
function initializeCharacterPositions() {
    const ROOM_SIZE = CONFIG.ROOM_SIZE;
    const ROOM_SPACING = CONFIG.ROOM_SPACING;
    
    // Player 1 positions
    gameState.playerCharacters[1] = {
        center: { x: -100, y: -100, active: false, vx: 0, vy: 0, momentum: { x: 0, y: 0 } },
        player1_zone: { x: 0, y: -ROOM_SIZE * ROOM_SPACING - 100, active: false, vx: 0, vy: 0, momentum: { x: 0, y: 0 } },
        player2_zone: { x: ROOM_SIZE * ROOM_SPACING + 100, y: -100, active: false, vx: 0, vy: 0, momentum: { x: 0, y: 0 } },
        player3_zone: { x: -ROOM_SIZE * ROOM_SPACING - 100, y: -100, active: false, vx: 0, vy: 0, momentum: { x: 0, y: 0 } },
        frantic_zone: { x: -100, y: ROOM_SIZE * ROOM_SPACING + 100, active: false, vx: 0, vy: 0, momentum: { x: 0, y: 0 } }
    };
    
    // Player 2 positions
    gameState.playerCharacters[2] = {
        center: { x: 0, y: 0, active: false, vx: 0, vy: 0, momentum: { x: 0, y: 0 } },
        player1_zone: { x: 0, y: -ROOM_SIZE * ROOM_SPACING, active: false, vx: 0, vy: 0, momentum: { x: 0, y: 0 } },
        player2_zone: { x: ROOM_SIZE * ROOM_SPACING, y: 0, active: false, vx: 0, vy: 0, momentum: { x: 0, y: 0 } },
        player3_zone: { x: -ROOM_SIZE * ROOM_SPACING, y: 0, active: false, vx: 0, vy: 0, momentum: { x: 0, y: 0 } },
        frantic_zone: { x: 0, y: ROOM_SIZE * ROOM_SPACING, active: false, vx: 0, vy: 0, momentum: { x: 0, y: 0 } }
    };
    
    // Player 3 positions
    gameState.playerCharacters[3] = {
        center: { x: 100, y: 100, active: false, vx: 0, vy: 0, momentum: { x: 0, y: 0 } },
        player1_zone: { x: 100, y: -ROOM_SIZE * ROOM_SPACING + 100, active: false, vx: 0, vy: 0, momentum: { x: 0, y: 0 } },
        player2_zone: { x: ROOM_SIZE * ROOM_SPACING - 100, y: 100, active: false, vx: 0, vy: 0, momentum: { x: 0, y: 0 } },
        player3_zone: { x: -ROOM_SIZE * ROOM_SPACING + 100, y: 100, active: false, vx: 0, vy: 0, momentum: { x: 0, y: 0 } },
        frantic_zone: { x: 100, y: ROOM_SIZE * ROOM_SPACING - 100, active: false, vx: 0, vy: 0, momentum: { x: 0, y: 0 } }
    };
}
// ========== physics.js ==========
// Constants
const FRICTION = CONFIG.FRICTION;
const MAX_SPEED = CONFIG.MAX_PUCK_SPEED;
const PUCK_RADIUS = CONFIG.PUCK_RADIUS;
const PADDLE_RADIUS = CONFIG.PADDLE_RADIUS;

// Helper functions
function isPointInRoom(x, y, roomName) {
    const room = rooms[roomName];
    return Math.abs(x - room.x) <= room.width/2 && 
           Math.abs(y - room.y) <= room.height/2;
}

function isPointInTunnel(x, y) {
    for (const [roomName, room] of Object.entries(rooms)) {
        for (const [connectionName, tunnel] of Object.entries(room.connections)) {
            const tunnelX = room.x + tunnel.x;
            const tunnelY = room.y + tunnel.y;
            
            if (Math.abs(x - tunnelX) <= tunnel.width/2 && 
                Math.abs(y - tunnelY) <= tunnel.height/2) {
                return true;
            }
        }
    }
    return false;
}

function constrainCharacterToRoom(character, roomName) {
    const room = rooms[roomName];
    const cornerRadius = CONFIG.CORNER_RADIUS;
    
    const left = room.x - room.width/2 + PADDLE_RADIUS;
    const right = room.x + room.width/2 - PADDLE_RADIUS;
    const top = room.y - room.height/2 + PADDLE_RADIUS;
    const bottom = room.y + room.height/2 - PADDLE_RADIUS;
    
    // First constrain to basic rectangle
    character.x = Math.max(left, Math.min(right, character.x));
    character.y = Math.max(top, Math.min(bottom, character.y));
    
    // Check rounded corners
    const corners = [
        { x: left + cornerRadius, y: top + cornerRadius },    // Top-left
        { x: right - cornerRadius, y: top + cornerRadius },   // Top-right
        { x: left + cornerRadius, y: bottom - cornerRadius },  // Bottom-left
        { x: right - cornerRadius, y: bottom - cornerRadius }  // Bottom-right
    ];
    
    // Check each corner
    for (let i = 0; i < corners.length; i++) {
        const corner = corners[i];
        const inCornerX = (i % 2 === 0) ? character.x < corner.x : character.x > corner.x;
        const inCornerY = (i < 2) ? character.y < corner.y : character.y > corner.y;
        
        if (inCornerX && inCornerY) {
            const dist = distance(character, corner);
            if (dist > cornerRadius) {
                // Push character out of rounded corner
                const angle = Math.atan2(character.y - corner.y, character.x - corner.x);
                character.x = corner.x + Math.cos(angle) * cornerRadius;
                character.y = corner.y + Math.sin(angle) * cornerRadius;
            }
        }
    }
}

function updatePuck() {
    // Apply friction
    gameState.puck.vx *= FRICTION;
    gameState.puck.vy *= FRICTION;
    
    // Apply gravity to Z-axis
    gameState.puck.vz -= gameState.puck.gravity;
    gameState.puck.z += gameState.puck.vz;
    
    // Bounce on ground (much less bouncy)
    if (gameState.puck.z <= 0) {
        gameState.puck.z = 0;
        gameState.puck.vz *= -0.3; // Much less bounce
        
        // Stop very small bounces
        if (Math.abs(gameState.puck.vz) < 1.0) {
            gameState.puck.vz = 0;
        }
    }
    
    // Limit max speed
    const speed = Math.sqrt(gameState.puck.vx ** 2 + gameState.puck.vy ** 2);
    if (speed > MAX_SPEED) {
        gameState.puck.vx = (gameState.puck.vx / speed) * MAX_SPEED;
        gameState.puck.vy = (gameState.puck.vy / speed) * MAX_SPEED;
    }
    
    // Update trail
    gameState.puck.trail.push({x: gameState.puck.x, y: gameState.puck.y});
    if (gameState.puck.trail.length > CONFIG.TRAIL_LENGTH) {
        gameState.puck.trail.shift();
    }
    
    // Step-wise movement to prevent tunneling through walls
    const steps = Math.ceil(Math.sqrt(gameState.puck.vx ** 2 + gameState.puck.vy ** 2) / PUCK_RADIUS);
    const stepX = gameState.puck.vx / steps;
    const stepY = gameState.puck.vy / steps;
    
    for (let i = 0; i < steps; i++) {
        // Store previous position
        const prevX = gameState.puck.x;
        const prevY = gameState.puck.y;
        
        // Move one step
        gameState.puck.x += stepX;
        gameState.puck.y += stepY;
        
        // Check for wall nudging (very small push when touching walls)
        checkWallNudge();
        
        // Check if we're still in a valid position
        const currentRoom = gameState.puck.currentRoom;
        const room = rooms[currentRoom];
        
        if (room && !isPointInTunnel(gameState.puck.x, gameState.puck.y)) {
            const cornerRadius = CONFIG.CORNER_RADIUS;
            const left = room.x - room.width/2 + PUCK_RADIUS;
            const right = room.x + room.width/2 - PUCK_RADIUS;
            const top = room.y - room.height/2 + PUCK_RADIUS;
            const bottom = room.y + room.height/2 - PUCK_RADIUS;
            
            let hitWall = false;
            
            // Basic rectangular bounds
            if (gameState.puck.x < left || gameState.puck.x > right) {
                gameState.puck.x = prevX;
                gameState.puck.vx *= -CONFIG.WALL_BOUNCE;
                hitWall = true;
            }
            
            if (gameState.puck.y < top || gameState.puck.y > bottom) {
                gameState.puck.y = prevY;
                gameState.puck.vy *= -CONFIG.WALL_BOUNCE;
                hitWall = true;
            }
            
            // Check rounded corners
            if (!hitWall) {
                const corners = [
                    { x: left + cornerRadius, y: top + cornerRadius },    // Top-left
                    { x: right - cornerRadius, y: top + cornerRadius },   // Top-right
                    { x: left + cornerRadius, y: bottom - cornerRadius },  // Bottom-left
                    { x: right - cornerRadius, y: bottom - cornerRadius }  // Bottom-right
                ];
                
                for (let j = 0; j < corners.length; j++) {
                    const corner = corners[j];
                    const inCornerX = (j % 2 === 0) ? gameState.puck.x < corner.x : gameState.puck.x > corner.x;
                    const inCornerY = (j < 2) ? gameState.puck.y < corner.y : gameState.puck.y > corner.y;
                    
                    if (inCornerX && inCornerY) {
                        const dist = distance(gameState.puck, corner);
                        if (dist > cornerRadius) {
                            // Bounce off rounded corner
                            const angle = Math.atan2(gameState.puck.y - corner.y, gameState.puck.x - corner.x);
                            gameState.puck.x = corner.x + Math.cos(angle) * cornerRadius;
                            gameState.puck.y = corner.y + Math.sin(angle) * cornerRadius;
                            
                            // Reflect velocity
                            const normal = { x: Math.cos(angle), y: Math.sin(angle) };
                            const dot = gameState.puck.vx * normal.x + gameState.puck.vy * normal.y;
                            gameState.puck.vx -= 2 * dot * normal.x;
                            gameState.puck.vy -= 2 * dot * normal.y;
                            gameState.puck.vx *= CONFIG.WALL_BOUNCE;
                            gameState.puck.vy *= CONFIG.WALL_BOUNCE;
                            
                            hitWall = true;
                            break;
                        }
                    }
                }
            }
            
            if (hitWall) {
                createBounceEffect(gameState.puck.x, gameState.puck.y);
                break; // Stop moving this frame
            }
        }
    }
    
    // Update puck's current room
    updatePuckRoom();
    
    // Check collisions with ALL characters
    for (let playerId = 1; playerId <= 3; playerId++) {
        for (let roomName in gameState.playerCharacters[playerId]) {
            const character = gameState.playerCharacters[playerId][roomName];
            
            const dx = gameState.puck.x - character.x;
            const dy = gameState.puck.y - character.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            // Magnet effect - pull puck closer and match player velocity
            if (character.active && gameState.powerUps.playerEffects[playerId].magnet > 0 && distance < 120) {
                const magnetForce = 0.35;
                const dampingForce = 0.85; // Reduce puck velocity to prevent orbiting
                
                // Pull toward player
                gameState.puck.vx -= (dx / distance) * magnetForce;
                gameState.puck.vy -= (dy / distance) * magnetForce;
                
                // Add player's velocity to puck (so it follows player movement)
                gameState.puck.vx += character.vx * 0.3;
                gameState.puck.vy += character.vy * 0.3;
                
                // Apply damping to reduce excessive speed and orbiting
                gameState.puck.vx *= dampingForce;
                gameState.puck.vy *= dampingForce;
            }
            
            if (distance < PUCK_RADIUS + PADDLE_RADIUS) {
                const force = 0.3;
                const normalX = dx / distance;
                const normalY = dy / distance;
                
                // Softer bounce if magnet is active
                const bounceFactor = gameState.powerUps.playerEffects[playerId].magnet > 0 ? 0.05 : 1;
                
                gameState.puck.vx += normalX * force * bounceFactor;
                gameState.puck.vy += normalY * force * bounceFactor;
                
                const overlap = PUCK_RADIUS + PADDLE_RADIUS - distance;
                gameState.puck.x += normalX * overlap;
                gameState.puck.y += normalY * overlap;
            }
        }
    }
    
    handlePuckBoundaries();
}

function updatePuckRoom() {
    // Don't update room during portal transition
    if (gameState.portalTransition.active) return;
    
    // Update cooldown
    if (gameState.portalTransition.cooldown > 0) {
        gameState.portalTransition.cooldown--;
    }
    
    gameState.puck.lastRoom = gameState.puck.currentRoom;
    
    // Check if puck is entering a tunnel/portal
    const currentRoom = rooms[gameState.puck.currentRoom];
    if (currentRoom && currentRoom.connections && gameState.portalTransition.cooldown === 0) {
        for (const [targetRoomName, tunnel] of Object.entries(currentRoom.connections)) {
            const tunnelX = currentRoom.x + tunnel.x;
            const tunnelY = currentRoom.y + tunnel.y;
            
            if (Math.abs(gameState.puck.x - tunnelX) <= tunnel.width/2 && 
                Math.abs(gameState.puck.y - tunnelY) <= tunnel.height/2) {
                // Puck entered a portal!
                startPortalTransition(gameState.puck.currentRoom, targetRoomName);
                return;
            }
        }
    }
    
    // Normal room boundary checking
    for (const [roomName, room] of Object.entries(rooms)) {
        if (isPointInRoom(gameState.puck.x, gameState.puck.y, roomName)) {
            if (gameState.puck.currentRoom !== roomName) {
                gameState.puck.currentRoom = roomName;
                gameState.currentRoom = roomName;
                if (window.updateActiveCharacters) window.updateActiveCharacters();
                if (window.updateRoomIndicator) window.updateRoomIndicator();
            }
            return;
        }
    }
    
    if (!isPointInTunnel(gameState.puck.x, gameState.puck.y)) {
        const room = rooms[gameState.puck.lastRoom];
        const left = room.x - room.width/2 + PUCK_RADIUS;
        const right = room.x + room.width/2 - PUCK_RADIUS;
        const top = room.y - room.height/2 + PUCK_RADIUS;
        const bottom = room.y + room.height/2 - PUCK_RADIUS;
        
        gameState.puck.x = Math.max(left, Math.min(right, gameState.puck.x));
        gameState.puck.y = Math.max(top, Math.min(bottom, gameState.puck.y));
    }
}

function startPortalTransition(fromRoom, toRoom) {
    const targetRoom = rooms[toRoom];
    const sourceRoom = rooms[fromRoom];
    
    // Find the matching tunnel in the target room
    let exitTunnel = null;
    for (const [connName, tunnel] of Object.entries(targetRoom.connections)) {
        if (connName === fromRoom) {
            exitTunnel = tunnel;
            break;
        }
    }
    
    if (!exitTunnel) return;
    
    // Calculate exit position - push puck away from portal to avoid re-entry
    const exitX = targetRoom.x + exitTunnel.x;
    const exitY = targetRoom.y + exitTunnel.y;
    
    // Calculate direction away from portal
    let pushX = 0, pushY = 0;
    const pushDistance = 80; // Distance to push puck from portal
    
    // Determine push direction based on which wall the portal is on
    if (Math.abs(exitTunnel.x) > Math.abs(exitTunnel.y)) {
        // Portal is on left/right wall
        pushX = exitTunnel.x > 0 ? -pushDistance : pushDistance;
    } else {
        // Portal is on top/bottom wall
        pushY = exitTunnel.y > 0 ? -pushDistance : pushDistance;
    }
    
    // Start the transition
    gameState.portalTransition = {
        active: true,
        startTime: Date.now(),
        duration: 400,
        fromRoom: fromRoom,
        toRoom: toRoom,
        fromPos: { x: gameState.puck.x, y: gameState.puck.y },
        toPos: { x: exitX + pushX, y: exitY + pushY },
        cooldown: 0 // Will be set when transition completes
    };
    
    // Preserve velocity direction but reduce magnitude during transition
    gameState.puck.vx *= 0.5;
    gameState.puck.vy *= 0.5;
}

function updatePortalTransition() {
    if (!gameState.portalTransition.active) return;
    
    const elapsed = Date.now() - gameState.portalTransition.startTime;
    const progress = Math.min(elapsed / gameState.portalTransition.duration, 1);
    
    if (progress >= 1) {
        // Transition complete
        gameState.puck.x = gameState.portalTransition.toPos.x;
        gameState.puck.y = gameState.portalTransition.toPos.y;
        gameState.puck.currentRoom = gameState.portalTransition.toRoom;
        gameState.currentRoom = gameState.portalTransition.toRoom;
        gameState.portalTransition.active = false;
        
        // Set cooldown to prevent immediate re-entry (about 1 second)
        gameState.portalTransition.cooldown = 60;
        
        if (window.updateActiveCharacters) window.updateActiveCharacters();
        if (window.updateRoomIndicator) window.updateRoomIndicator();
    }
}

function checkWallNudge() {
    const currentRoom = gameState.puck.currentRoom;
    const room = rooms[currentRoom];
    if (!room) return;
    
    const cornerRadius = CONFIG.CORNER_RADIUS;
    const left = room.x - room.width/2 + PUCK_RADIUS;
    const right = room.x + room.width/2 - PUCK_RADIUS;
    const top = room.y - room.height/2 + PUCK_RADIUS;
    const bottom = room.y + room.height/2 - PUCK_RADIUS;
    
    // Small nudge away from walls when very close
    const nudgeForce = 1; // 1 pixel push
    
    if (Math.abs(gameState.puck.x - left) < 2 && !isPointInTunnel(gameState.puck.x, gameState.puck.y)) {
        gameState.puck.x += nudgeForce;
    }
    if (Math.abs(gameState.puck.x - right) < 2 && !isPointInTunnel(gameState.puck.x, gameState.puck.y)) {
        gameState.puck.x -= nudgeForce;
    }
    if (Math.abs(gameState.puck.y - top) < 2 && !isPointInTunnel(gameState.puck.x, gameState.puck.y)) {
        gameState.puck.y += nudgeForce;
    }
    if (Math.abs(gameState.puck.y - bottom) < 2 && !isPointInTunnel(gameState.puck.x, gameState.puck.y)) {
        gameState.puck.y -= nudgeForce;
    }
}

function handlePuckBoundaries() {
    for (const [roomName, room] of Object.entries(rooms)) {
        if (isPointInRoom(gameState.puck.x, gameState.puck.y, roomName)) {
            const left = room.x - room.width/2;
            const right = room.x + room.width/2;
            const top = room.y - room.height/2;
            const bottom = room.y + room.height/2;
            
            if (gameState.puck.x - PUCK_RADIUS <= left) {
                if (!hasTunnelAt(room, 'left', gameState.puck.y)) {
                    gameState.puck.vx = Math.abs(gameState.puck.vx) * 0.7;
                    gameState.puck.x = left + PUCK_RADIUS;
                }
            }
            
            if (gameState.puck.x + PUCK_RADIUS >= right) {
                if (!hasTunnelAt(room, 'right', gameState.puck.y)) {
                    gameState.puck.vx = -Math.abs(gameState.puck.vx) * 0.7;
                    gameState.puck.x = right - PUCK_RADIUS;
                }
            }
            
            if (gameState.puck.y - PUCK_RADIUS <= top) {
                if (!hasTunnelAt(room, 'top', gameState.puck.x)) {
                    gameState.puck.vy = Math.abs(gameState.puck.vy) * 0.7;
                    gameState.puck.y = top + PUCK_RADIUS;
                }
            }
            
            if (gameState.puck.y + PUCK_RADIUS >= bottom) {
                if (!hasTunnelAt(room, 'bottom', gameState.puck.x)) {
                    gameState.puck.vy = -Math.abs(gameState.puck.vy) * 0.7;
                    gameState.puck.y = bottom - PUCK_RADIUS;
                }
            }
            
            break;
        }
    }
}

function hasTunnelAt(room, direction, coordinate) {
    if (!room.connections) return false;
    
    for (const [connectionName, tunnel] of Object.entries(room.connections)) {
        const tunnelX = room.x + tunnel.x;
        const tunnelY = room.y + tunnel.y;
        
        switch (direction) {
            case 'left':
            case 'right':
                if (Math.abs(coordinate - tunnelY) <= tunnel.height/2) {
                    return true;
                }
                break;
            case 'top':
            case 'bottom':
                if (Math.abs(coordinate - tunnelX) <= tunnel.width/2) {
                    return true;
                }
                break;
        }
    }
    return false;
}

function checkGoals() {
    for (const [roomName, room] of Object.entries(rooms)) {
        if (room.goals && isPointInRoom(gameState.puck.x, gameState.puck.y, roomName)) {
            for (const goal of room.goals) {
                let inGoal = false;
                const goalX = room.x + goal.x;
                const goalY = room.y + goal.y;
                
                switch (goal.direction) {
                    case 'top':
                        inGoal = gameState.puck.y <= goalY + 15 && 
                                Math.abs(gameState.puck.x - goalX) <= CONFIG.GOAL_SIZE/2;
                        break;
                    case 'right':
                        inGoal = gameState.puck.x >= goalX - 15 && 
                                Math.abs(gameState.puck.y - goalY) <= CONFIG.GOAL_SIZE/2;
                        break;
                    case 'bottom':
                        inGoal = gameState.puck.y >= goalY - 15 && 
                                Math.abs(gameState.puck.x - goalX) <= CONFIG.GOAL_SIZE/2;
                        break;
                    case 'left':
                        inGoal = gameState.puck.x <= goalX + 15 && 
                                Math.abs(gameState.puck.y - goalY) <= CONFIG.GOAL_SIZE/2;
                        break;
                }
                
                if (inGoal) {
                    // Check if goal is protected by shield
                    if (gameState.powerUps.playerEffects[goal.owner].shield > 0) {
                        // Bounce the puck away instead of scoring
                        gameState.puck.vx *= -1;
                        gameState.puck.vy *= -1;
                        createBounceEffect(goalX, goalY);
                    } else {
                        // Normal scoring
                        for (let playerId = 1; playerId <= 3; playerId++) {
                            if (playerId !== goal.owner) {
                                gameState.playerScores[playerId]++;
                            }
                        }
                        if (window.updateScoreDisplay) window.updateScoreDisplay();
                        
                        setTimeout(() => {
                            if (window.startFaceOff) window.startFaceOff('center');
                        }, 1000);
                    }
                    
                    return;
                }
            }
        }
    }
}

function tryKick(playerId) {
    // No kicks during face-off
    if (gameState.faceOff.active) return false;
    
    // Check cooldown
    if (gameState.kickCooldowns[playerId] > 0) return false;
    
    const activeCharacter = getActiveCharacter(playerId);
    if (!activeCharacter) return false;
    
    // Check if close enough to puck
    const dist = distance(activeCharacter, gameState.puck);
    if (dist > CONFIG.KICK_RANGE) return false;
    
    // Calculate kick direction (away from player)
    const dx = gameState.puck.x - activeCharacter.x;
    const dy = gameState.puck.y - activeCharacter.y;
    const kickDist = Math.sqrt(dx * dx + dy * dy);
    
    if (kickDist < 5) return false; // Too close, no direction
    
    // Calculate player's speed for variable kick strength
    let playerSpeed = 0;
    if (activeCharacter.momentum) {
        playerSpeed = Math.sqrt(activeCharacter.momentum.x * activeCharacter.momentum.x + 
                              activeCharacter.momentum.y * activeCharacter.momentum.y);
    } else if (activeCharacter.vx !== undefined && activeCharacter.vy !== undefined) {
        // For AI players who don't use momentum system
        playerSpeed = Math.sqrt(activeCharacter.vx * activeCharacter.vx + 
                              activeCharacter.vy * activeCharacter.vy);
    }
    
    // Calculate relative velocity between player and puck
    const relativeVx = activeCharacter.momentum ? activeCharacter.momentum.x : (activeCharacter.vx || 0);
    const relativeVy = activeCharacter.momentum ? activeCharacter.momentum.y : (activeCharacter.vy || 0);
    const relativeDotProduct = (dx * relativeVx + dy * relativeVy) / kickDist;
    
    // Base kick force + bonus based on player speed and direction
    const speedBonus = Math.max(0, relativeDotProduct) * 0.5; // Bonus if moving toward puck
    const kickStrength = 1 + (playerSpeed / CONFIG.PLAYER_SPEED) * 0.5 + speedBonus;
    
    // Apply variable kick force
    const forceX = (dx / kickDist) * CONFIG.KICK_FORCE * kickStrength;
    const forceY = (dy / kickDist) * CONFIG.KICK_FORCE * kickStrength;
    
    gameState.puck.vx += forceX;
    gameState.puck.vy += forceY;
    
    // Add Z-velocity for 3D effect (lift the puck)
    const horizontalForce = Math.sqrt(forceX * forceX + forceY * forceY);
    gameState.puck.vz += horizontalForce * 0.15; // Lift proportional to kick strength
    
    // Set cooldown
    gameState.kickCooldowns[playerId] = 15; // Reduced cooldown for more responsive kicking
    
    // Visual effect - make player glow briefly
    if (activeCharacter) {
        activeCharacter.kickEffect = 10;
        // Stronger kicks get stronger visual effect
        activeCharacter.kickStrength = kickStrength;
    }
    
    return true;
}

function getActiveCharacter(playerId) {
    const currentRoom = gameState.puck.currentRoom;
    return gameState.playerCharacters[playerId][currentRoom];
}

function updateCooldowns() {
    for (let playerId = 1; playerId <= 3; playerId++) {
        if (gameState.kickCooldowns[playerId] > 0) {
            gameState.kickCooldowns[playerId]--;
        }
    }
    
    // Update kick effects
    for (let playerId = 1; playerId <= 3; playerId++) {
        for (let roomName in gameState.playerCharacters[playerId]) {
            const character = gameState.playerCharacters[playerId][roomName];
            if (character.kickEffect > 0) {
                character.kickEffect--;
            }
        }
    }
}

function createBounceEffect(x, y) {
    gameState.bounceEffects.push({
        x: x,
        y: y,
        life: 15, // frames to live
        maxLife: 15,
        size: 20
    });
}

function updateBounceEffects() {
    for (let i = gameState.bounceEffects.length - 1; i >= 0; i--) {
        const effect = gameState.bounceEffects[i];
        effect.life--;
        
        if (effect.life <= 0) {
            gameState.bounceEffects.splice(i, 1);
        }
    }
}

function checkPuckStuck() {
    const currentPos = { x: gameState.puck.x, y: gameState.puck.y };
    const lastPos = gameState.puckStuck.position;
    const moved = distance(currentPos, lastPos);
    
    if (moved < gameState.puckStuck.threshold) {
        gameState.puckStuck.timer++;
        
        if (gameState.puckStuck.timer >= gameState.puckStuck.timeLimit) {
            // Puck is stuck, start face-off in current room
            // startFaceOff(gameState.puck.currentRoom); // This will be imported from another module
            gameState.puckStuck.timer = 0;
            return true; // Return true to indicate face-off should start
        }
    } else {
        // Puck moved, reset timer
        gameState.puckStuck.timer = 0;
        gameState.puckStuck.position = { x: currentPos.x, y: currentPos.y };
    }
    
    return false;
}
// ========== ai.js ==========
// AI difficulty settings
const aiSettings = {
    easy: {
        reactionTime: 30,    // Frames between decisions
        predictionFrames: 5,  // How far ahead to predict
        accuracy: 0.6,        // Shot accuracy
        strategy: 0.3,        // Strategic thinking level
        kickTiming: 0.4       // How well they time kicks
    },
    medium: {
        reactionTime: 15,
        predictionFrames: 15,
        accuracy: 0.8,
        strategy: 0.7,
        kickTiming: 0.7
    },
    hard: {
        reactionTime: 5,
        predictionFrames: 30,
        accuracy: 0.95,
        strategy: 0.95,
        kickTiming: 0.9
    }
};

function initAI() {
    // Initialize AI state for each player
    for (let playerId = 1; playerId <= 3; playerId++) {
        if (!gameState.aiState[playerId]) {
            gameState.aiState[playerId] = {
                lastDecision: 0,
                target: { x: 0, y: 0 },
                strategy: 'follow',
                stuckCounter: 0,
                lastPos: { x: 0, y: 0 }
            };
        }
    }
}

function updateAI(playerId) {
    if (gameState.playerTypes[playerId] !== 'ai') return;
    
    const settings = aiSettings[gameState.aiDifficulty || 'medium'];
    const aiState = gameState.aiState[playerId];
    const activeCharacter = getActiveCharacter(playerId);
    if (!activeCharacter) return;
    
    // Make decisions only occasionally (intelligence difference)
    if (gameState.gameTime - aiState.lastDecision >= settings.reactionTime) {
        makeAIDecision(playerId, settings, aiState, activeCharacter);
        aiState.lastDecision = gameState.gameTime;
    }
    
    // But ALWAYS move toward current target every frame (same speed as humans)
    if (aiState.target) {
        moveAITowardTarget(activeCharacter, aiState.target, playerId);
    }
    
    // AI Kicking logic - MORE AGGRESSIVE!
    const distToPuck = distance(activeCharacter, gameState.puck);
    if (distToPuck <= CONFIG.KICK_RANGE && gameState.kickCooldowns[playerId] === 0) {
        // Less strategic delays - kick more often!
        const delayKick = settings.strategy > 0.8 ? shouldDelayKick(playerId, activeCharacter, settings) : false;
        
        if (!delayKick) {
            // Decide whether to kick based on situation
            const shouldKick = shouldAIKick(playerId, activeCharacter, settings);
            if (shouldKick) {
                if (window.tryKick) window.tryKick(playerId);
            }
        }
    }
}

function makeAIDecision(playerId, settings, aiState, activeCharacter) {
    const puckDistance = distance(activeCharacter, gameState.puck);
    const currentRoom = gameState.puck.currentRoom;
    const threatLevel = evaluateThreatLevel(playerId);
    
    // Check for power-up opportunities first (smart AI only)
    const powerUpTarget = shouldGoForPowerUp(playerId, activeCharacter, settings);
    if (powerUpTarget && threatLevel < 0.7) {
        aiState.strategy = 'get_powerup';
        aiState.powerUpTarget = powerUpTarget.box;
    }
    // Enhanced strategy decision based on multiple factors
    else if (Math.random() < settings.strategy) {
        // Smart strategic behavior with threat assessment
        if (threatLevel > 0.8) {
            // High threat - prioritize defense
            aiState.strategy = 'urgent_defend';
        } else if (currentRoom === 'center') {
            // In center room - AGGRESSIVE goal-seeking behavior
            if (puckDistance < 150) {
                // Close to puck - always try to score!
                aiState.strategy = 'push_to_portal';
            } else {
                // Far from puck - aggressively intercept
                aiState.strategy = 'intercept';
            }
        } else if (isMyDefensiveZone(currentRoom, playerId)) {
            // Enhanced defensive decision making
            if (isAloneInDefensiveZone(playerId)) {
                // Alone with only goal - push puck through portal for safety
                aiState.strategy = 'escape_to_portal';
            } else if (puckDistance < 200 && threatLevel > 0.5) {
                aiState.strategy = 'urgent_defend';
            } else if (puckDistance < 150) {
                aiState.strategy = 'clear_puck';
            } else {
                aiState.strategy = 'goalkeeper';
            }
        } else if (puckDistance < 150) {
            // Close to puck - ALWAYS be aggressive!
            const enemyGoal = getBestEnemyGoal(currentRoom, playerId);
            if (enemyGoal) {
                aiState.strategy = 'shoot_on_goal';
            } else {
                // No direct goal available - push toward center to find scoring opportunities
                aiState.strategy = 'attack';
            }
        } else {
            // Far from puck - aggressive intercept, never just "position"
            aiState.strategy = 'intercept';
        }
    } else {
        // Simple AI behavior - just follow the ball
        aiState.strategy = 'follow';
    }
    
    // Set target based on strategy
    setAITarget(playerId, aiState, activeCharacter, settings);
}

function setAITarget(playerId, aiState, activeCharacter, settings) {
    let targetX = activeCharacter.x;
    let targetY = activeCharacter.y;
    
    switch (aiState.strategy) {
        case 'follow':
            // Simple: just go to where ball is now
            targetX = gameState.puck.x;
            targetY = gameState.puck.y;
            break;
            
        case 'intercept':
            // Smart: predict where puck will be
            const prediction = predictPuckPosition(settings.predictionFrames);
            targetX = prediction.x;
            targetY = prediction.y;
            break;
            
        case 'defend':
            const myGoal = getMyGoal(gameState.puck.currentRoom, playerId);
            if (myGoal) {
                // Position between puck and goal
                const dx = gameState.puck.x - myGoal.x;
                const dy = gameState.puck.y - myGoal.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                const defensiveDistance = 80;
                
                targetX = myGoal.x + (dx / dist) * defensiveDistance;
                targetY = myGoal.y + (dy / dist) * defensiveDistance;
            }
            break;
            
        case 'attack':
            const enemyGoal = getBestEnemyGoal(gameState.puck.currentRoom, playerId);
            if (enemyGoal) {
                // Smart AI aims better, dumb AI has more spread
                const inaccuracy = (1 - settings.accuracy) * 120;
                targetX = enemyGoal.x + (Math.random() - 0.5) * inaccuracy;
                targetY = enemyGoal.y + (Math.random() - 0.5) * inaccuracy;
            } else {
                // No enemy goal visible, go for ball
                targetX = gameState.puck.x;
                targetY = gameState.puck.y;
            }
            break;
            
        case 'position':
            // No passive positioning - always chase the puck!
            targetX = gameState.puck.x;
            targetY = gameState.puck.y;
            break;
            
        case 'push_to_portal':
            // In center room - find best portal to push puck toward
            const centerRoom = rooms['center'];
            const portals = [];
            
            // Collect all portals except the one leading to our defensive zone
            for (const [targetRoom, tunnel] of Object.entries(centerRoom.connections)) {
                if (targetRoom !== `player${playerId}_zone`) {
                    portals.push({
                        name: targetRoom,
                        x: centerRoom.x + tunnel.x,
                        y: centerRoom.y + tunnel.y,
                        tunnel: tunnel
                    });
                }
            }
            
            // Find the best portal based on AI intelligence
            if (portals.length > 0) {
                let bestPortal;
                
                // ALWAYS prioritize enemy defensive zones for scoring!
                const enemyPortals = portals.filter(p => 
                    p.name.includes('player') && !p.name.includes(`player${playerId}`)
                );
                
                if (enemyPortals.length > 0) {
                    // Choose the closest enemy portal for faster scoring
                    bestPortal = enemyPortals.reduce((closest, portal) => {
                        const distToCurrent = distance(activeCharacter, portal);
                        const distToClosest = distance(activeCharacter, closest);
                        return distToCurrent < distToClosest ? portal : closest;
                    });
                } else {
                    // No enemy portals available, try frantic zone
                    const franticPortal = portals.find(p => p.name === 'frantic_zone');
                    bestPortal = franticPortal || portals[0];
                }
                
                // Position behind puck to push it toward portal
                const puckToPortalX = bestPortal.x - gameState.puck.x;
                const puckToPortalY = bestPortal.y - gameState.puck.y;
                const dist = Math.sqrt(puckToPortalX * puckToPortalX + puckToPortalY * puckToPortalY);
                
                if (dist > 0) {
                    // Get behind the puck relative to the portal
                    targetX = gameState.puck.x - (puckToPortalX / dist) * 50;
                    targetY = gameState.puck.y - (puckToPortalY / dist) * 50;
                }
            }
            break;
            
        case 'get_powerup':
            // Go for power-up
            if (aiState.powerUpTarget) {
                targetX = aiState.powerUpTarget.x;
                targetY = aiState.powerUpTarget.y;
            }
            break;
            
        case 'urgent_defend':
            // Emergency defensive positioning
            const urgentGoal = getMyGoal(gameState.puck.currentRoom, playerId);
            if (urgentGoal) {
                const optimalPos = getOptimalDefensivePosition(playerId, urgentGoal);
                targetX = optimalPos.x;
                targetY = optimalPos.y;
            }
            break;
            
        case 'clear_puck':
            // Get behind puck to clear it away from our goal
            const clearGoal = getMyGoal(gameState.puck.currentRoom, playerId);
            if (clearGoal) {
                const puckToGoalX = clearGoal.x - gameState.puck.x;
                const puckToGoalY = clearGoal.y - gameState.puck.y;
                const dist = Math.sqrt(puckToGoalX * puckToGoalX + puckToGoalY * puckToGoalY);
                
                if (dist > 0) {
                    // Position behind puck relative to our goal
                    targetX = gameState.puck.x - (puckToGoalX / dist) * 40;
                    targetY = gameState.puck.y - (puckToGoalY / dist) * 40;
                }
            }
            break;
            
        case 'shoot_on_goal':
            // Position for optimal shot on enemy goal
            const shootGoal = getBestEnemyGoal(gameState.puck.currentRoom, playerId);
            if (shootGoal) {
                // Get behind puck for a shot
                const puckToGoalX = shootGoal.x - gameState.puck.x;
                const puckToGoalY = shootGoal.y - gameState.puck.y;
                const dist = Math.sqrt(puckToGoalX * puckToGoalX + puckToGoalY * puckToGoalY);
                
                if (dist > 0) {
                    targetX = gameState.puck.x - (puckToGoalX / dist) * 35;
                    targetY = gameState.puck.y - (puckToGoalY / dist) * 35;
                }
            }
            break;
            
        case 'support':
            // Even "support" should be aggressive - go for the puck!
            const supportPrediction = predictPuckPosition(15);
            targetX = supportPrediction.x;
            targetY = supportPrediction.y;
            break;
            
        case 'strategic_position':
            // No passive positioning - always go for intercept!
            const futurePos = predictPuckPosition(20);
            targetX = futurePos.x;
            targetY = futurePos.y;
            break;
            
        case 'goalkeeper':
            // Optimal goalkeeper positioning
            const gkGoal = getMyGoal(gameState.puck.currentRoom, playerId);
            if (gkGoal) {
                const optimalGKPos = getGoalkeeperPosition(playerId, gameState.puck, gkGoal);
                targetX = optimalGKPos.x;
                targetY = optimalGKPos.y;
            }
            break;
            
        case 'escape_to_portal':
            // Push puck through portal when alone in defensive zone
            const escapeRoom = rooms[gameState.puck.currentRoom];
            if (escapeRoom && escapeRoom.connections) {
                // Find the portal (there should only be one in defensive zones)
                const portalEntry = Object.entries(escapeRoom.connections)[0];
                if (portalEntry) {
                    const [portalName, tunnel] = portalEntry;
                    const portalX = escapeRoom.x + tunnel.x;
                    const portalY = escapeRoom.y + tunnel.y;
                    
                    // Get behind puck to push toward portal
                    const puckToPortalX = portalX - gameState.puck.x;
                    const puckToPortalY = portalY - gameState.puck.y;
                    const dist = Math.sqrt(puckToPortalX * puckToPortalX + puckToPortalY * puckToPortalY);
                    
                    if (dist > 0) {
                        targetX = gameState.puck.x - (puckToPortalX / dist) * 40;
                        targetY = gameState.puck.y - (puckToPortalY / dist) * 40;
                    }
                }
            }
            break;
    }
    
    // Store target for continuous movement
    aiState.target = { x: targetX, y: targetY };
}

function moveAITowardTarget(character, target, playerId) {
    const dx = target.x - character.x;
    const dy = target.y - character.y;
    const dist = Math.sqrt(dx * dx + dy * dy);
    
    if (dist < 10) {
        // Apply friction when at target
        if (character.momentum) {
            character.momentum.x *= 0.85;
            character.momentum.y *= 0.85;
        }
        return;
    }
    
    // Initialize momentum if not exists
    if (character.momentum === undefined) {
        character.momentum = { x: 0, y: 0 };
    }
    
    const aiState = gameState.aiState[playerId];
    
    // Check if AI is stuck (hasn't moved much)
    const movedDistance = distance(character, aiState.lastPos);
    if (movedDistance < 1) {
        aiState.stuckCounter++;
    } else {
        aiState.stuckCounter = Math.max(0, aiState.stuckCounter - 1);
    }
    
    // EXACT same speed as human players!
    const speedBoost = gameState.powerUps.playerEffects[playerId].speed > 0 ? 1.5 : 1;
    const slowdownFactor = gameState.powerUps.playerEffects[playerId].slowdown > 0 ? 0.5 : 1;
    const speed = CONFIG.PLAYER_SPEED * speedBoost * slowdownFactor;
    
    // Target velocity
    let targetVx = (dx / dist) * speed;
    let targetVy = (dy / dist) * speed;
    
    // Anti-stuck behavior
    if (aiState.stuckCounter > CONFIG.STUCK_THRESHOLD) {
        // Add random movement to escape corners
        const randomAngle = Math.random() * Math.PI * 2;
        const randomForce = CONFIG.ANTI_STUCK_FORCE;
        targetVx += Math.cos(randomAngle) * randomForce;
        targetVy += Math.sin(randomAngle) * randomForce;
        
        // Reset counter after escape attempt
        if (aiState.stuckCounter > CONFIG.STUCK_RESET) {
            aiState.stuckCounter = 0;
        }
    }
    
    // Apply acceleration to momentum (AI uses slightly higher acceleration for responsiveness)
    const acceleration = 0.4;
    character.momentum.x += (targetVx - character.momentum.x) * acceleration;
    character.momentum.y += (targetVy - character.momentum.y) * acceleration;
    
    // Store current position for next frame
    aiState.lastPos = { x: character.x, y: character.y };
    
    // Apply momentum to position
    character.x += character.momentum.x;
    character.y += character.momentum.y;
    
    // Update visual velocity
    character.vx = character.momentum.x * 0.8;
    character.vy = character.momentum.y * 0.8;
    
    // Constrain to current room
    const currentRoom = gameState.puck.currentRoom;
    constrainCharacterToRoom(character, currentRoom);
}

// Helper functions
function getActiveCharacter(playerId) {
    const currentRoom = gameState.puck.currentRoom;
    const character = gameState.playerCharacters[playerId][currentRoom];
    return character && character.active ? character : null;
}

function isMyDefensiveZone(roomName, playerId) {
    return roomName === `player${playerId}_zone`;
}

function getMyGoal(roomName, playerId) {
    const room = rooms[roomName];
    if (!room || !room.goals) return null;
    
    const myGoal = room.goals.find(goal => goal.owner === playerId);
    if (!myGoal) return null;
    
    return {
        x: room.x + myGoal.x,
        y: room.y + myGoal.y
    };
}

function getBestEnemyGoal(roomName, playerId) {
    const room = rooms[roomName];
    if (!room || !room.goals) return null;
    
    const enemyGoals = room.goals.filter(goal => goal.owner !== playerId);
    if (enemyGoals.length === 0) return null;
    
    // Pick closest enemy goal
    const activeChar = getActiveCharacter(playerId);
    let bestGoal = null;
    let bestDistance = Infinity;
    
    enemyGoals.forEach(goal => {
        const goalPos = { x: room.x + goal.x, y: room.y + goal.y };
        const dist = distance(activeChar, goalPos);
        if (dist < bestDistance) {
            bestDistance = dist;
            bestGoal = goalPos;
        }
    });
    
    return bestGoal;
}

function predictPuckPosition(frames) {
    // Enhanced prediction with physics simulation
    let futureX = gameState.puck.x;
    let futureY = gameState.puck.y;
    let vx = gameState.puck.vx;
    let vy = gameState.puck.vy;
    
    // Simulate physics for each frame
    for (let i = 0; i < frames; i++) {
        // Apply friction
        vx *= CONFIG.FRICTION;
        vy *= CONFIG.FRICTION;
        
        // Update position
        futureX += vx;
        futureY += vy;
        
        // Simple wall bounce prediction (room boundaries)
        const room = rooms[gameState.puck.currentRoom];
        if (room) {
            const minX = room.x - room.width/2 + CONFIG.PUCK_RADIUS;
            const maxX = room.x + room.width/2 - CONFIG.PUCK_RADIUS;
            const minY = room.y - room.height/2 + CONFIG.PUCK_RADIUS;
            const maxY = room.y + room.height/2 - CONFIG.PUCK_RADIUS;
            
            if (futureX < minX || futureX > maxX) vx *= -CONFIG.WALL_BOUNCE;
            if (futureY < minY || futureY > maxY) vy *= -CONFIG.WALL_BOUNCE;
        }
    }
    
    return { x: futureX, y: futureY };
}

function isMovingTowardMyGoal(playerId) {
    const myGoal = getMyGoal(gameState.puck.currentRoom, playerId);
    if (!myGoal) return false;
    
    // Check if puck is moving toward my goal
    const futurePos = predictPuckPosition(10);
    const currentDist = distance(gameState.puck, myGoal);
    const futureDist = distance(futurePos, myGoal);
    
    return futureDist < currentDist;
}

function getOtherAIPlayers(excludePlayerId) {
    const aiPlayers = [];
    for (let id = 1; id <= 3; id++) {
        if (id !== excludePlayerId && gameState.playerTypes[id] === 'ai') {
            const char = getActiveCharacter(id);
            if (char) {
                aiPlayers.push({ id, character: char });
            }
        }
    }
    return aiPlayers;
}

function getNearestPowerUp(character) {
    if (!gameState.powerUps.spawned || gameState.powerUps.spawned.length === 0) return null;
    
    let nearest = null;
    let nearestDist = Infinity;
    
    gameState.powerUps.spawned.forEach(powerUp => {
        if (powerUp.room === gameState.puck.currentRoom) {
            const dist = distance(character, powerUp);
            if (dist < nearestDist) {
                nearestDist = dist;
                nearest = { box: powerUp, distance: dist };
            }
        }
    });
    
    return nearest;
}

function shouldGoForPowerUp(playerId, character, settings) {
    const powerUp = getNearestPowerUp(character);
    if (!powerUp) return false;
    
    // Smart AI evaluates if power-up is worth going for
    if (settings.strategy < 0.6) return false; // Only medium/hard AI goes for power-ups
    
    const puckDist = distance(character, gameState.puck);
    const powerUpDist = powerUp.distance;
    
    // Consider power-up if it's closer than puck or if we're not in immediate danger
    if (powerUpDist < puckDist * 0.7) {
        // Check if we already have too many power-ups
        const activeEffects = gameState.powerUps.playerEffects[playerId];
        const activeCount = Object.values(activeEffects).filter(v => v > 0).length;
        
        if (activeCount < 2) {
            // Check if puck is threatening our goal
            if (!isMovingTowardMyGoal(playerId) || puckDist > 200) {
                return powerUp;
            }
        }
    }
    
    return false;
}

function getOptimalDefensivePosition(playerId, myGoal) {
    // Calculate optimal defensive position based on puck trajectory
    const puckToGoalX = myGoal.x - gameState.puck.x;
    const puckToGoalY = myGoal.y - gameState.puck.y;
    const dist = Math.sqrt(puckToGoalX * puckToGoalX + puckToGoalY * puckToGoalY);
    
    if (dist < 0.01) return myGoal; // Puck is at goal
    
    // Position between predicted puck position and goal
    const defensiveRatio = 0.3; // Stay 30% of distance from goal
    const optimalX = myGoal.x - (puckToGoalX / dist) * (dist * defensiveRatio);
    const optimalY = myGoal.y - (puckToGoalY / dist) * (dist * defensiveRatio);
    
    return { x: optimalX, y: optimalY };
}

function evaluateThreatLevel(playerId) {
    // Evaluate how dangerous the current situation is
    const myGoal = getMyGoal(gameState.puck.currentRoom, playerId);
    if (!myGoal) return 0;
    
    const puckDist = distance(gameState.puck, myGoal);
    const puckSpeed = Math.sqrt(gameState.puck.vx * gameState.puck.vx + gameState.puck.vy * gameState.puck.vy);
    const movingToward = isMovingTowardMyGoal(playerId);
    
    let threatLevel = 0;
    
    if (movingToward) {
        threatLevel += 0.5;
        if (puckDist < 200) threatLevel += 0.3;
        if (puckSpeed > 5) threatLevel += 0.2;
    }
    
    return Math.min(threatLevel, 1);
}

function isAloneInDefensiveZone(playerId) {
    const currentRoom = gameState.puck.currentRoom;
    if (!isMyDefensiveZone(currentRoom, playerId)) return false;
    
    // Check if any other players are active in this room
    for (let i = 1; i <= 3; i++) {
        if (i !== playerId) {
            const char = gameState.playerCharacters[i][currentRoom];
            if (char && char.active) {
                return false;
            }
        }
    }
    return true;
}

function getGoalkeeperPosition(playerId, puckPos, goalPos) {
    // Optimal goalkeeper position between puck and goal
    const dx = puckPos.x - goalPos.x;
    const dy = puckPos.y - goalPos.y;
    const dist = Math.sqrt(dx * dx + dy * dy);
    
    if (dist < 0.01) return goalPos;
    
    // Position 80-120 units from goal depending on puck distance
    const optimalDist = Math.min(120, Math.max(80, dist * 0.3));
    
    return {
        x: goalPos.x + (dx / dist) * optimalDist,
        y: goalPos.y + (dy / dist) * optimalDist
    };
}

function shouldDelayKick(playerId, character, settings) {
    // Determine if AI should wait for better kick opportunity
    const currentRoom = gameState.puck.currentRoom;
    const aiState = gameState.aiState[playerId];
    
    // Don't delay if defending urgently
    if (aiState.strategy === 'urgent_defend' || aiState.strategy === 'clear_puck') {
        return false;
    }
    
    // Check kick alignment with intended target
    let targetAlignment = 0;
    if (aiState.strategy === 'shoot_on_goal' || aiState.strategy === 'attack') {
        const enemyGoal = getBestEnemyGoal(currentRoom, playerId);
        if (enemyGoal) {
            targetAlignment = calculateKickAlignment(character, gameState.puck, enemyGoal);
        }
    } else if (aiState.strategy === 'push_to_portal') {
        // Check alignment with best portal
        const room = rooms[currentRoom];
        if (room && room.connections) {
            let bestPortalAlignment = 0;
            for (const [name, tunnel] of Object.entries(room.connections)) {
                const portalPos = { x: room.x + tunnel.x, y: room.y + tunnel.y };
                const alignment = calculateKickAlignment(character, gameState.puck, portalPos);
                bestPortalAlignment = Math.max(bestPortalAlignment, alignment);
            }
            targetAlignment = bestPortalAlignment;
        }
    }
    
    // Delay kick if alignment is poor (less than 70% for smart AI)
    const alignmentThreshold = settings.strategy > 0.7 ? 0.7 : 0.5;
    return targetAlignment < alignmentThreshold;
}

function shouldAIKick(playerId, character, settings) {
    const currentRoom = gameState.puck.currentRoom;
    const aiState = gameState.aiState[playerId];
    
    // BE MORE AGGRESSIVE - kick more often!
    if (Math.random() > Math.max(0.7, settings.strategy)) return false;
    
    // Enhanced kicking decisions based on current strategy
    switch (aiState.strategy) {
        case 'shoot_on_goal':
        case 'attack':
            // Always kick when in attacking mode and aligned with goal
            const enemyGoal = getBestEnemyGoal(currentRoom, playerId);
            if (enemyGoal) {
                const alignment = calculateKickAlignment(character, gameState.puck, enemyGoal);
                return alignment > 0.4; // Much lower threshold for more aggressive attacking!
            }
            break;
            
        case 'clear_puck':
        case 'urgent_defend':
            // Always kick to clear danger
            return true;
            
        case 'goalkeeper':
            // Goalkeeper kicks if puck is close and moving slowly
            const puckSpeed = Math.sqrt(gameState.puck.vx * gameState.puck.vx + gameState.puck.vy * gameState.puck.vy);
            if (puckSpeed < 3) {
                return true; // Clear slow-moving pucks
            }
            break;
            
        case 'escape_to_portal':
            // Always kick toward portal when escaping
            return true;
            
        case 'push_to_portal':
            // Enhanced portal targeting
            if (currentRoom === 'center') {
                const centerRoom = rooms['center'];
                let bestPortal = null;
                let bestScore = -1;
                
                for (const [targetRoom, tunnel] of Object.entries(centerRoom.connections)) {
                    if (targetRoom !== `player${playerId}_zone`) {
                        const portalX = centerRoom.x + tunnel.x;
                        const portalY = centerRoom.y + tunnel.y;
                        
                        const alignment = calculateKickAlignment(character, gameState.puck, {x: portalX, y: portalY});
                        const distance = Math.sqrt((portalX - character.x)**2 + (portalY - character.y)**2);
                        
                        // Score based on alignment and whether it's an enemy zone
                        let score = alignment;
                        if (targetRoom.includes('player') && !targetRoom.includes(`${playerId}`)) {
                            score *= 1.5; // Prefer enemy zones
                        }
                        
                        // Smart AI considers distance too
                        if (settings.strategy > 0.8) {
                            score *= (1000 - distance) / 1000; // Prefer closer portals
                        }
                        
                        if (score > bestScore && alignment > 0.5) {
                            bestScore = score;
                            bestPortal = { x: portalX, y: portalY, name: targetRoom };
                        }
                    }
                }
                
                return bestPortal !== null;
            }
            break;
    }
    
    // General kicking logic - more aggressive
    if (currentRoom !== 'center') {
        const enemyGoal = getBestEnemyGoal(currentRoom, playerId);
        if (enemyGoal) {
            const alignment = calculateKickAlignment(character, gameState.puck, enemyGoal);
            const puckToGoal = distance(gameState.puck, enemyGoal);
            
            // More aggressive kick thresholds
            let kickThreshold = 0.4;
            if (gameState.powerUps.playerEffects[playerId].speed > 0) {
                kickThreshold = 0.3; // Even more aggressive with speed boost
            }
            
            if (alignment > kickThreshold && puckToGoal > 80) {
                return true;
            }
        }
    } else {
        // In center room - actively kick toward enemy zones
        const room = rooms[currentRoom];
        if (room && room.connections) {
            // Prioritize kicking toward enemy defensive zones
            for (const [zoneName, tunnel] of Object.entries(room.connections)) {
                if (zoneName.includes('player') && !zoneName.includes(`${playerId}`)) {
                    const portalPos = { x: room.x + tunnel.x, y: room.y + tunnel.y };
                    const kickAlignment = calculateKickAlignment(character, gameState.puck, portalPos);
                    
                    // Aggressively kick toward opponent zones
                    if (kickAlignment > 0.5) {
                        return true; // Attack opponent zones
                    }
                }
            }
        }
    }
    
    // Defensive kicks - more aggressive clearing
    if (isMyDefensiveZone(currentRoom, playerId)) {
        const myGoal = getMyGoal(currentRoom, playerId);
        if (myGoal) {
            const puckToMyGoal = distance(gameState.puck, myGoal);
            const threatLevel = evaluateThreatLevel(playerId);
            
            // More frequent defensive clearing
            if (threatLevel > 0.3 || puckToMyGoal < 200) {
                return true;
            }
        }
    }
    
    return false;
}

function calculateKickAlignment(character, puck, target) {
    // Calculate how well aligned character is to kick puck toward target
    const charToPuckX = puck.x - character.x;
    const charToPuckY = puck.y - character.y;
    const puckToTargetX = target.x - puck.x;
    const puckToTargetY = target.y - puck.y;
    
    const charToPuckDist = Math.sqrt(charToPuckX * charToPuckX + charToPuckY * charToPuckY);
    const puckToTargetDist = Math.sqrt(puckToTargetX * puckToTargetX + puckToTargetY * puckToTargetY);
    
    if (charToPuckDist < 0.01 || puckToTargetDist < 0.01) return 0;
    
    // Normalize vectors
    const charToPuckNormX = charToPuckX / charToPuckDist;
    const charToPuckNormY = charToPuckY / charToPuckDist;
    const puckToTargetNormX = puckToTargetX / puckToTargetDist;
    const puckToTargetNormY = puckToTargetY / puckToTargetDist;
    
    // Calculate dot product (how aligned the vectors are)
    const dotProduct = charToPuckNormX * puckToTargetNormX + charToPuckNormY * puckToTargetNormY;
    
    // Return value between 0 and 1 (1 = perfect alignment)
    return Math.max(0, dotProduct);
}
// ========== powerups.js ==========
function spawnPowerUp() {
    if (Math.random() < CONFIG.POWERUP_SPAWN_CHANCE && gameState.powerUps.spawned.length < 3) {
        const types = ['magnet', 'speed', 'slowdown', 'shield'];
        const type = types[Math.floor(Math.random() * types.length)];
        const room = rooms[gameState.currentRoom];
        
        // Spawn in a random position within the current room
        const x = room.x + (Math.random() - 0.5) * (room.width - 100);
        const y = room.y + (Math.random() - 0.5) * (room.height - 100);
        
        gameState.powerUps.spawned.push({
            type: type,
            x: x,
            y: y,
            room: gameState.currentRoom,
            rotation: 0,
            pulsePhase: 0,
            lifetime: CONFIG.POWERUP_LIFETIME
        });
    }
}

function updatePowerUps() {
    // Update spawned power-ups and remove expired ones
    for (let i = gameState.powerUps.spawned.length - 1; i >= 0; i--) {
        const powerUp = gameState.powerUps.spawned[i];
        powerUp.rotation += 0.02;
        powerUp.pulsePhase += 0.1;
        powerUp.lifetime--;
        
        // Remove if expired
        if (powerUp.lifetime <= 0) {
            gameState.powerUps.spawned.splice(i, 1);
        }
    }
    
    // Check for power-up collection
    for (let playerId = 1; playerId <= 3; playerId++) {
        const character = getActiveCharacter(playerId);
        if (!character) continue;
        
        for (let i = gameState.powerUps.spawned.length - 1; i >= 0; i--) {
            const powerUp = gameState.powerUps.spawned[i];
            if (powerUp.room === gameState.currentRoom && 
                distance(character, powerUp) < CONFIG.PADDLE_RADIUS + CONFIG.POWERUP_SIZE) {
                
                // Collect power-up
                applyPowerUp(playerId, powerUp.type);
                gameState.powerUps.spawned.splice(i, 1);
            }
        }
    }
    
    // Update active effects durations
    for (let playerId = 1; playerId <= 3; playerId++) {
        const effects = gameState.powerUps.playerEffects[playerId];
        for (let effect in effects) {
            if (effects[effect] > 0) {
                effects[effect]--;
            }
        }
    }
}

function applyPowerUp(playerId, type) {
    switch (type) {
        case 'magnet':
        case 'speed':
        case 'shield':
            gameState.powerUps.playerEffects[playerId][type] = CONFIG.POWERUP_DURATION[type];
            break;
        case 'slowdown':
            // Slowdown affects opponents, not the player who picks it up
            for (let i = 1; i <= 3; i++) {
                if (i !== playerId) {
                    gameState.powerUps.playerEffects[i].slowdown = CONFIG.POWERUP_DURATION.slowdown;
                }
            }
            break;
    }
}

function updatePowerUpDisplay() {
    const icons = {
        magnet: 'üß≤',
        speed: '‚ö°',
        shield: 'üõ°Ô∏è'
    };
    
    for (let playerId = 1; playerId <= 3; playerId++) {
        const effects = gameState.powerUps.playerEffects[playerId];
        const element = document.getElementById(`powerup${playerId}`);
        let display = '';
        
        // Check each effect
        for (let effect in effects) {
            if (effects[effect] > 0) {
                const seconds = Math.ceil(effects[effect] / 60);
                display += `${icons[effect] || effect} ${seconds}s `;
            }
        }
        
        // Slowdown is now a player effect
        if (effects.slowdown > 0) {
            const seconds = Math.ceil(effects.slowdown / 60);
            display += `üêå ${seconds}s `;
        }
        
        element.textContent = display.trim();
    }
}

function getActiveCharacter(playerId) {
    const currentRoom = gameState.puck.currentRoom;
    return gameState.playerCharacters[playerId][currentRoom];
}
// ========== faceoff.js ==========
function startFaceOff(room, customPosition) {
    const targetRoom = room || gameState.puck.currentRoom || 'center';
    const roomData = rooms[targetRoom];
    
    gameState.faceOff.active = true;
    gameState.faceOff.countdown = 180; // 3 seconds
    gameState.faceOff.room = targetRoom;
    gameState.faceOff.position = customPosition || { x: roomData.x, y: roomData.y };
    
    // Place puck at face-off position
    gameState.puck.x = gameState.faceOff.position.x;
    gameState.puck.y = gameState.faceOff.position.y;
    gameState.puck.vx = 0;
    gameState.puck.vy = 0;
    gameState.puck.currentRoom = targetRoom;
    
    // Update current room
    gameState.currentRoom = targetRoom;
    
    // Position players in triangle around puck
    positionPlayersForFaceOff();
}

function positionPlayersForFaceOff() {
    const faceOffDistance = 150; // Distance from puck
    const room = gameState.faceOff.room;
    
    // Position active characters in equilateral triangle
    for (let playerId = 1; playerId <= 3; playerId++) {
        const character = gameState.playerCharacters[playerId][room];
        if (character) {
            const angle = ((playerId - 1) * 120 - 90) * Math.PI / 180; // -90, 30, 150 degrees
            character.x = gameState.faceOff.position.x + Math.cos(angle) * faceOffDistance;
            character.y = gameState.faceOff.position.y + Math.sin(angle) * faceOffDistance;
            character.vx = 0;
            character.vy = 0;
            if (character.momentum) {
                character.momentum.x = 0;
                character.momentum.y = 0;
            }
            
            // Ensure character is within room bounds
            constrainCharacterToRoom(character, room);
        }
    }
    
    if (window.updateActiveCharacters) window.updateActiveCharacters();
}

function updateFaceOff() {
    if (!gameState.faceOff.active) return;
    
    gameState.faceOff.countdown--;
    
    // During countdown, prevent all movement and kicks
    if (gameState.faceOff.countdown > 0) {
        // Keep puck frozen
        gameState.puck.vx = 0;
        gameState.puck.vy = 0;
        
        // Keep players at their positions
        if (gameState.faceOff.countdown % 20 === 0) { // Re-position every 20 frames
            positionPlayersForFaceOff();
        }
    } else {
        // Face-off complete, resume normal play
        gameState.faceOff.active = false;
        
        // Make sure active characters are updated properly
        if (window.updateActiveCharacters) window.updateActiveCharacters();
        if (window.updateRoomIndicator) window.updateRoomIndicator();
    }
}
// ========== input.js ==========
function initInput() {
    document.addEventListener('keydown', handleKeyDown);
    document.addEventListener('keyup', handleKeyUp);
}

function handleKeyDown(e) {
    if (!gameState.gameStarted) return;
    
    gameState.keys[e.key.toLowerCase()] = true;
    
    // Kick controls - mapped to be near movement keys
    if (e.key === ' ' && gameState.playerTypes[1] === 'human') { // Space for Player 1 (arrows)
        e.preventDefault();
        tryKick(1);
    }
    if (e.key === 'Shift' && e.location === 1 && gameState.playerTypes[2] === 'human') { // Left Shift for Player 2 (WASD)
        e.preventDefault();
        tryKick(2);
    }
    if (e.key.toLowerCase() === 'h' && gameState.playerTypes[3] === 'human') { // H for Player 3 (IJKL)
        e.preventDefault();
        tryKick(3);
    }
    
    if (e.key.toLowerCase() === 'r') {
        e.preventDefault();
        if (window.initGame) window.initGame();
    }
    if (e.key === 'Escape') {
        e.preventDefault();
        gameState.isPaused = !gameState.isPaused;
    }
    if (e.key.toLowerCase() === 'm') {
        e.preventDefault();
        if (window.showGameMenu) window.showGameMenu();
    }
}

function handleKeyUp(e) {
    gameState.keys[e.key.toLowerCase()] = false;
}

function updatePlayerMovement(playerId, keys) {
    const characters = gameState.playerCharacters[playerId];
    
    for (let roomName in characters) {
        const character = characters[roomName];
        if (!character.active) continue;
        
        let moveX = 0, moveY = 0;
        
        // Get movement based on player controls
        switch (playerId) {
            case 1: // Arrow keys
                if (gameState.keys['arrowup']) moveY -= 1;
                if (gameState.keys['arrowdown']) moveY += 1;
                if (gameState.keys['arrowleft']) moveX -= 1;
                if (gameState.keys['arrowright']) moveX += 1;
                break;
            case 2: // WASD
                if (gameState.keys['w']) moveY -= 1;
                if (gameState.keys['s']) moveY += 1;
                if (gameState.keys['a']) moveX -= 1;
                if (gameState.keys['d']) moveX += 1;
                break;
            case 3: // IJKL
                if (gameState.keys['i']) moveY -= 1;
                if (gameState.keys['k']) moveY += 1;
                if (gameState.keys['j']) moveX -= 1;
                if (gameState.keys['l']) moveX += 1;
                break;
        }
        
        return { moveX, moveY };
    }
    
    return { moveX: 0, moveY: 0 };
}
// ========== rendering.js ==========
let renderCtx;

// 3D perspective settings
const PERSPECTIVE_CONFIG = {
    horizon: 200,        // Y position of horizon line
    maxScale: 1.2,       // Maximum scale for objects at bottom
    minScale: 0.6,       // Minimum scale for objects at top
    vanishingY: -500,    // Y position of vanishing point
    wallHeight: 3,       // Virtual wall height (reduced to 3px)
    wallThickness: 25,   // Wall thickness
    cameraHeight: 300,   // Camera height above the floor
    cameraAngle: 0.3     // Camera tilt angle (radians)
};

function getPerspectiveScale(y, canvasHeight) {
    // Calculate perspective scale based on Y position
    const normalizedY = (y - PERSPECTIVE_CONFIG.horizon) / canvasHeight;
    const scale = PERSPECTIVE_CONFIG.minScale + 
                 (PERSPECTIVE_CONFIG.maxScale - PERSPECTIVE_CONFIG.minScale) * 
                 Math.max(0, Math.min(1, normalizedY + 0.5));
    return scale;
}

function project3DPoint(x, y, z, cameraX, cameraY) {
    // Project 3D point to 2D screen coordinates considering camera position
    const relativeX = x - cameraX;
    const relativeY = y - cameraY;
    
    // Simple perspective projection
    const distance = Math.sqrt(relativeX * relativeX + relativeY * relativeY);
    const perspective = PERSPECTIVE_CONFIG.cameraHeight / (PERSPECTIVE_CONFIG.cameraHeight - z);
    
    // Camera angle effect
    const angleOffsetY = z * Math.sin(PERSPECTIVE_CONFIG.cameraAngle) * 0.5;
    
    return {
        x: cameraX + relativeX * perspective,
        y: cameraY + relativeY * perspective + angleOffsetY,
        scale: perspective
    };
}

function getWallTopY(baseY, cameraY) {
    // Calculate where the top of the wall appears on screen
    const relativeY = baseY - cameraY;
    const wallTop = project3DPoint(0, baseY, PERSPECTIVE_CONFIG.wallHeight, 0, cameraY);
    return wallTop.y;
}

function initCanvas() {
    const canvas = document.getElementById('gameCanvas');
    renderCtx = canvas.getContext('2d');
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    
    window.addEventListener('resize', () => {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
    });
    
    return { canvas, ctx: renderCtx };
}

function render() {
    if (!gameState.gameStarted) return;
    
    const canvas = renderCtx.canvas;
    const gradient = renderCtx.createRadialGradient(canvas.width/2, canvas.height/2, 0, canvas.width/2, canvas.height/2, Math.max(canvas.width, canvas.height)/2);
    gradient.addColorStop(0, '#0f0f23');
    gradient.addColorStop(1, '#0a0a0a');
    renderCtx.fillStyle = gradient;
    renderCtx.fillRect(0, 0, canvas.width, canvas.height);
    
    renderCtx.save();
    renderCtx.translate(-gameState.camera.x, -gameState.camera.y);
    
    drawRooms();
    drawTunnels(); // Draws the swirl effects through wall openings
    drawPowerUps();
    drawPuckTrail();
    drawAllCharacters();
    drawBounceEffects();   // Draw bounce effects after characters
    drawPuck();           // Draw puck LAST so it's always visible on top
    
    if (gameState.isPaused) {
        renderCtx.fillStyle = 'rgba(0, 0, 0, 0.7)';
        renderCtx.fillRect(gameState.camera.x, gameState.camera.y, canvas.width, canvas.height);
        
        renderCtx.fillStyle = '#00ffff';
        renderCtx.font = '48px Arial';
        renderCtx.textAlign = 'center';
        renderCtx.fillText('PAUSAD', gameState.camera.x + canvas.width/2, gameState.camera.y + canvas.height/2);
    }
    
    // Draw face-off countdown
    if (gameState.faceOff.active && gameState.faceOff.countdown > 0) {
        const seconds = Math.ceil(gameState.faceOff.countdown / 60);
        
        // Draw countdown circle
        renderCtx.strokeStyle = '#00ffff';
        renderCtx.lineWidth = 3;
        renderCtx.beginPath();
        renderCtx.arc(gameState.puck.x, gameState.puck.y, 200, 0, Math.PI * 2);
        renderCtx.stroke();
        
        // Draw countdown number
        renderCtx.fillStyle = '#00ffff';
        renderCtx.font = 'bold 72px Arial';
        renderCtx.textAlign = 'center';
        renderCtx.textBaseline = 'middle';
        renderCtx.fillText(seconds, gameState.puck.x, gameState.puck.y - 250);
        
        // Draw "FACE-OFF" text
        renderCtx.font = 'bold 36px Arial';
        renderCtx.fillText('FACE-OFF', gameState.puck.x, gameState.puck.y - 320);
    }
    
    renderCtx.restore();
}

function drawRooms() {
    Object.entries(rooms).forEach(([roomName, room]) => {
        const cornerRadius = CONFIG.CORNER_RADIUS;
        const x = room.x - room.width/2;
        const y = room.y - room.height/2;
        const width = room.width;
        const height = room.height;
        const wallThickness = 15; // Wall thickness for 3D effect
        
        // Draw 3D walls with depth
        draw3DWalls(x, y, width, height, cornerRadius, room);
        
        // Draw room floor with rounded corners
        renderCtx.beginPath();
        renderCtx.moveTo(x + cornerRadius, y);
        renderCtx.lineTo(x + width - cornerRadius, y);
        renderCtx.quadraticCurveTo(x + width, y, x + width, y + cornerRadius);
        renderCtx.lineTo(x + width, y + height - cornerRadius);
        renderCtx.quadraticCurveTo(x + width, y + height, x + width - cornerRadius, y + height);
        renderCtx.lineTo(x + cornerRadius, y + height);
        renderCtx.quadraticCurveTo(x, y + height, x, y + height - cornerRadius);
        renderCtx.lineTo(x, y + cornerRadius);
        renderCtx.quadraticCurveTo(x, y, x + cornerRadius, y);
        renderCtx.closePath();
        
        // Fill floor with lighter color
        renderCtx.fillStyle = room.color + '20'; // Very transparent floor
        renderCtx.fill();
        
        // Add inner shadow for depth
        renderCtx.save();
        renderCtx.clip(); // Clip to room shape
        renderCtx.shadowColor = 'rgba(0, 0, 0, 0.3)';
        renderCtx.shadowBlur = 10;
        renderCtx.shadowOffsetX = 0;
        renderCtx.shadowOffsetY = 0;
        renderCtx.strokeStyle = 'rgba(0, 0, 0, 0.5)';
        renderCtx.lineWidth = 20;
        renderCtx.stroke();
        renderCtx.restore();
        
        renderCtx.fillStyle = room.type === 'frantic' ? '#ff00ff' : '#ffffff';
        renderCtx.font = room.type === 'frantic' ? 'bold 18px Arial' : '16px Arial';
        renderCtx.textAlign = 'center';
        const roomDisplayName = room.type === 'frantic' ? 'FRANTIC ZONE!' : 
                               room.type === 'defensive' ? `Player ${room.owner} Zone` : 
                               'CENTER';
        renderCtx.fillText(roomDisplayName, room.x, room.y - room.height/2 + 25);
        
        if (room.goals) {
            room.goals.forEach(goal => drawGoal(room, goal));
        }
    });
}

function draw3DWalls(x, y, width, height, cornerRadius, room) {
    const cameraX = gameState.camera.x;
    const cameraY = gameState.camera.y;
    const wallColor = room.type === 'frantic' ? '#ff00ff' : '#00ffff';
    const wallColorDark = room.type === 'frantic' ? '#cc00cc' : '#0099cc';
    const wallColorMedium = room.type === 'frantic' ? '#dd00dd' : '#0066cc';
    const thickness = PERSPECTIVE_CONFIG.wallThickness;
    
    // Get portal positions for this room to create openings
    const portals = [];
    if (room.connections) {
        Object.entries(room.connections).forEach(([connectionName, tunnel]) => {
            portals.push({
                x: room.x + tunnel.x,
                y: room.y + tunnel.y,
                width: tunnel.width,
                height: tunnel.height
            });
        });
    }
    
    // Generate curved wall segments that follow the rounded corners
    function generateWallPoints(centerX, centerY, w, h, radius, outset) {
        const points = [];
        const segmentsPerCorner = 36; // Even higher resolution for precise portal openings
        
        // Calculate the effective radius with outset
        const effectiveRadius = radius + outset;
        
        // Define the four corner centers
        const corners = [
            { x: centerX - w/2 + radius, y: centerY - h/2 + radius, startAngle: Math.PI, endAngle: Math.PI * 1.5 },     // Top-left
            { x: centerX + w/2 - radius, y: centerY - h/2 + radius, startAngle: Math.PI * 1.5, endAngle: Math.PI * 2 }, // Top-right  
            { x: centerX + w/2 - radius, y: centerY + h/2 - radius, startAngle: 0, endAngle: Math.PI * 0.5 },           // Bottom-right
            { x: centerX - w/2 + radius, y: centerY + h/2 - radius, startAngle: Math.PI * 0.5, endAngle: Math.PI }      // Bottom-left
        ];
        
        // For each corner, generate curved points
        corners.forEach((corner, cornerIndex) => {
            for (let i = 0; i <= segmentsPerCorner; i++) {
                const t = i / segmentsPerCorner;
                const angle = corner.startAngle + (corner.endAngle - corner.startAngle) * t;
                
                const pointX = corner.x + effectiveRadius * Math.cos(angle);
                const pointY = corner.y + effectiveRadius * Math.sin(angle);
                
                points.push([pointX, pointY]);
            }
            
            // Add straight edge points between corners (except after last corner)
            if (cornerIndex < 3) {
                const straightSegments = 36; // Much higher resolution for straight edges
                
                for (let i = 1; i <= straightSegments; i++) {
                    const t = i / (straightSegments + 1);
                    let straightX, straightY;
                    
                    if (cornerIndex === 0) { // Top edge
                        straightX = corner.x + effectiveRadius + t * (w - 2 * radius);
                        straightY = centerY - h/2 - outset;
                    } else if (cornerIndex === 1) { // Right edge
                        straightX = centerX + w/2 + outset;
                        straightY = corner.y + effectiveRadius + t * (h - 2 * radius);
                    } else if (cornerIndex === 2) { // Bottom edge
                        straightX = corner.x - effectiveRadius - t * (w - 2 * radius);
                        straightY = centerY + h/2 + outset;
                    }
                    
                    points.push([straightX, straightY]);
                }
            }
        });
        
        // Add final straight edge (left edge)
        const leftEdgeSegments = 36;
        const leftCorner = corners[3];
        for (let i = 1; i < leftEdgeSegments; i++) {
            const t = i / leftEdgeSegments;
            const straightX = centerX - w/2 - outset;
            const straightY = leftCorner.y - effectiveRadius - t * (h - 2 * radius);
            points.push([straightX, straightY]);
        }
        
        return points;
    }
    
    const outerPoints = generateWallPoints(x + width/2, y + height/2, width, height, cornerRadius, thickness);
    const innerPoints = generateWallPoints(x + width/2, y + height/2, width, height, cornerRadius, 0);
    
    // Helper function to check if a wall segment intersects with any portal
    function segmentIntersectsPortal(p1, p2) {
        return portals.some(portal => {
            const buffer = 5;
            const portalLeft = portal.x - portal.width/2 - buffer;
            const portalRight = portal.x + portal.width/2 + buffer;
            const portalTop = portal.y - portal.height/2 - buffer;
            const portalBottom = portal.y + portal.height/2 + buffer;
            
            // Check if either endpoint is inside the portal
            const p1Inside = p1[0] >= portalLeft && p1[0] <= portalRight && 
                           p1[1] >= portalTop && p1[1] <= portalBottom;
            const p2Inside = p2[0] >= portalLeft && p2[0] <= portalRight && 
                           p2[1] >= portalTop && p2[1] <= portalBottom;
            
            if (p1Inside || p2Inside) return true;
            
            // Check if segment crosses portal boundaries
            const segMinX = Math.min(p1[0], p2[0]);
            const segMaxX = Math.max(p1[0], p2[0]);
            const segMinY = Math.min(p1[1], p2[1]);
            const segMaxY = Math.max(p1[1], p2[1]);
            
            // Check if bounding boxes overlap
            return segMaxX >= portalLeft && segMinX <= portalRight &&
                   segMaxY >= portalTop && segMinY <= portalBottom;
        });
    }
    
    // Helper function to clip a line segment against portal boundaries
    function clipSegmentToPortals(p1, p2) {
        let clippedP1 = [...p1];
        let clippedP2 = [...p2];
        let fullyClipped = false;
        
        for (const portal of portals) {
            const buffer = 5;
            const portalLeft = portal.x - portal.width/2 - buffer;
            const portalRight = portal.x + portal.width/2 + buffer;
            const portalTop = portal.y - portal.height/2 - buffer;
            const portalBottom = portal.y + portal.height/2 + buffer;
            
            // Check if segment intersects portal
            const dx = clippedP2[0] - clippedP1[0];
            const dy = clippedP2[1] - clippedP1[1];
            
            // Find intersections with portal boundaries
            const intersections = [];
            
            // Check intersection with left edge
            if (dx !== 0) {
                const t = (portalLeft - clippedP1[0]) / dx;
                if (t >= 0 && t <= 1) {
                    const y = clippedP1[1] + t * dy;
                    if (y >= portalTop && y <= portalBottom) {
                        intersections.push({ t, x: portalLeft, y, edge: 'left' });
                    }
                }
            }
            
            // Check intersection with right edge
            if (dx !== 0) {
                const t = (portalRight - clippedP1[0]) / dx;
                if (t >= 0 && t <= 1) {
                    const y = clippedP1[1] + t * dy;
                    if (y >= portalTop && y <= portalBottom) {
                        intersections.push({ t, x: portalRight, y, edge: 'right' });
                    }
                }
            }
            
            // Check intersection with top edge
            if (dy !== 0) {
                const t = (portalTop - clippedP1[1]) / dy;
                if (t >= 0 && t <= 1) {
                    const x = clippedP1[0] + t * dx;
                    if (x >= portalLeft && x <= portalRight) {
                        intersections.push({ t, x, y: portalTop, edge: 'top' });
                    }
                }
            }
            
            // Check intersection with bottom edge
            if (dy !== 0) {
                const t = (portalBottom - clippedP1[1]) / dy;
                if (t >= 0 && t <= 1) {
                    const x = clippedP1[0] + t * dx;
                    if (x >= portalLeft && x <= portalRight) {
                        intersections.push({ t, x, y: portalBottom, edge: 'bottom' });
                    }
                }
            }
            
            // Check if segment is entirely inside portal
            const p1Inside = clippedP1[0] >= portalLeft && clippedP1[0] <= portalRight && 
                           clippedP1[1] >= portalTop && clippedP1[1] <= portalBottom;
            const p2Inside = clippedP2[0] >= portalLeft && clippedP2[0] <= portalRight && 
                           clippedP2[1] >= portalTop && clippedP2[1] <= portalBottom;
            
            if (p1Inside && p2Inside) {
                fullyClipped = true;
                break;
            }
            
            // Clip the segment
            if (intersections.length > 0) {
                intersections.sort((a, b) => a.t - b.t);
                
                if (p1Inside && !p2Inside) {
                    // P1 is inside, P2 is outside - clip P1 to exit point
                    const exitIntersection = intersections[intersections.length - 1];
                    clippedP1 = [exitIntersection.x, exitIntersection.y];
                } else if (!p1Inside && p2Inside) {
                    // P1 is outside, P2 is inside - clip P2 to entry point
                    const entryIntersection = intersections[0];
                    clippedP2 = [entryIntersection.x, entryIntersection.y];
                } else if (!p1Inside && !p2Inside && intersections.length >= 2) {
                    // Segment passes through portal completely
                    // We need to split this into two segments, but for now just skip it
                    fullyClipped = true;
                    break;
                }
            }
        }
        
        return { p1: clippedP1, p2: clippedP2, fullyClipped };
    }
    
    // Draw wall segments using the curved points (skip segments that cross portals)
    for (let i = 0; i < outerPoints.length; i++) {
        const nextI = (i + 1) % outerPoints.length;
        const outerP1 = outerPoints[i];
        const outerP2 = outerPoints[nextI];
        const innerP1 = innerPoints[i];
        const innerP2 = innerPoints[nextI];
        
        // Skip if segment intersects a portal
        if (segmentIntersectsPortal(outerP1, outerP2) || segmentIntersectsPortal(innerP1, innerP2)) {
            continue;
        }
        
        // Project floor points
        const outerFloor1 = project3DPoint(outerP1[0], outerP1[1], 0, cameraX, cameraY);
        const outerFloor2 = project3DPoint(outerP2[0], outerP2[1], 0, cameraX, cameraY);
        const innerFloor1 = project3DPoint(innerP1[0], innerP1[1], 0, cameraX, cameraY);
        const innerFloor2 = project3DPoint(innerP2[0], innerP2[1], 0, cameraX, cameraY);
        
        // Project wall top points
        const outerTop1 = project3DPoint(outerP1[0], outerP1[1], PERSPECTIVE_CONFIG.wallHeight, cameraX, cameraY);
        const outerTop2 = project3DPoint(outerP2[0], outerP2[1], PERSPECTIVE_CONFIG.wallHeight, cameraX, cameraY);
        const innerTop1 = project3DPoint(innerP1[0], innerP1[1], PERSPECTIVE_CONFIG.wallHeight, cameraX, cameraY);
        const innerTop2 = project3DPoint(innerP2[0], innerP2[1], PERSPECTIVE_CONFIG.wallHeight, cameraX, cameraY);
        
        // Calculate wall normal for this segment
        const wallNormalX = -(outerP2[1] - outerP1[1]);
        const wallNormalY = outerP2[0] - outerP1[0];
        const cameraDirX = cameraX - (outerP1[0] + outerP2[0]) / 2;
        const cameraDirY = cameraY - (outerP1[1] + outerP2[1]) / 2;
        const dotProduct = wallNormalX * cameraDirX + wallNormalY * cameraDirY;
        
        // Draw outer wall face (if facing away from camera)
        if (dotProduct < 0) {
            renderCtx.beginPath();
            renderCtx.moveTo(outerFloor1.x, outerFloor1.y);
            renderCtx.lineTo(outerFloor2.x, outerFloor2.y);
            renderCtx.lineTo(outerTop2.x, outerTop2.y);
            renderCtx.lineTo(outerTop1.x, outerTop1.y);
            renderCtx.closePath();
            
            renderCtx.fillStyle = wallColorDark + '90';
            renderCtx.fill();
            renderCtx.strokeStyle = wallColorDark;
            renderCtx.lineWidth = 1;
            renderCtx.stroke();
        }
        
        // Calculate inner wall normal
        const innerNormalX = -(innerP2[1] - innerP1[1]);
        const innerNormalY = innerP2[0] - innerP1[0];
        const innerCameraDirX = cameraX - (innerP1[0] + innerP2[0]) / 2;
        const innerCameraDirY = cameraY - (innerP1[1] + innerP2[1]) / 2;
        const innerDotProduct = innerNormalX * innerCameraDirX + innerNormalY * innerCameraDirY;
        
        // Draw inner wall face (if facing toward camera)
        if (innerDotProduct > 0) {
            renderCtx.beginPath();
            renderCtx.moveTo(innerFloor1.x, innerFloor1.y);
            renderCtx.lineTo(innerFloor2.x, innerFloor2.y);
            renderCtx.lineTo(innerTop2.x, innerTop2.y);
            renderCtx.lineTo(innerTop1.x, innerTop1.y);
            renderCtx.closePath();
            
            const gradient = renderCtx.createLinearGradient(
                (innerFloor1.x + innerFloor2.x) / 2, (innerFloor1.y + innerFloor2.y) / 2,
                (innerTop1.x + innerTop2.x) / 2, (innerTop1.y + innerTop2.y) / 2
            );
            gradient.addColorStop(0, wallColor + '80');
            gradient.addColorStop(1, wallColorMedium + '60');
            
            renderCtx.fillStyle = gradient;
            renderCtx.fill();
            renderCtx.strokeStyle = wallColor;
            renderCtx.lineWidth = 1;
            renderCtx.stroke();
        }
        
        // Draw wall top surface (showing thickness)
        renderCtx.beginPath();
        renderCtx.moveTo(outerTop1.x, outerTop1.y);
        renderCtx.lineTo(outerTop2.x, outerTop2.y);
        renderCtx.lineTo(innerTop2.x, innerTop2.y);
        renderCtx.lineTo(innerTop1.x, innerTop1.y);
        renderCtx.closePath();
        
        renderCtx.fillStyle = wallColorMedium + '70';
        renderCtx.fill();
        renderCtx.strokeStyle = wallColor;
        renderCtx.lineWidth = 1;
        renderCtx.stroke();
    }
    
    // Debug: visualize portal areas and skipped segments
    const DEBUG_PORTALS = false; // Set to false to disable debug
    if (DEBUG_PORTALS) {
        portals.forEach(portal => {
            const buffer = 5;
            const debugLeft = portal.x - portal.width/2 - buffer;
            const debugRight = portal.x + portal.width/2 + buffer;
            const debugTop = portal.y - portal.height/2 - buffer;
            const debugBottom = portal.y + portal.height/2 + buffer;
            
            // Draw portal area outline
            renderCtx.strokeStyle = '#ff0000';
            renderCtx.lineWidth = 2;
            renderCtx.strokeRect(debugLeft, debugTop, debugRight - debugLeft, debugBottom - debugTop);
            
            // Draw actual portal size
            renderCtx.strokeStyle = '#00ff00';
            renderCtx.lineWidth = 1;
            renderCtx.strokeRect(portal.x - portal.width/2, portal.y - portal.height/2, portal.width, portal.height);
        });
        
        // Show skipped wall segments
        for (let i = 0; i < outerPoints.length; i++) {
            const nextI = (i + 1) % outerPoints.length;
            const outerP1 = outerPoints[i];
            const outerP2 = outerPoints[nextI];
            
            if (segmentIntersectsPortal(outerP1, outerP2)) {
                renderCtx.strokeStyle = '#ffff00';
                renderCtx.lineWidth = 3;
                renderCtx.beginPath();
                renderCtx.moveTo(outerP1[0], outerP1[1]);
                renderCtx.lineTo(outerP2[0], outerP2[1]);
                renderCtx.stroke();
            }
        }
    }
    
    // Draw floor/playing surface (inner area)
    renderCtx.beginPath();
    renderCtx.moveTo(x + cornerRadius, y);
    renderCtx.lineTo(x + width - cornerRadius, y);
    renderCtx.quadraticCurveTo(x + width, y, x + width, y + cornerRadius);
    renderCtx.lineTo(x + width, y + height - cornerRadius);
    renderCtx.quadraticCurveTo(x + width, y + height, x + width - cornerRadius, y + height);
    renderCtx.lineTo(x + cornerRadius, y + height);
    renderCtx.quadraticCurveTo(x, y + height, x, y + height - cornerRadius);
    renderCtx.lineTo(x, y + cornerRadius);
    renderCtx.quadraticCurveTo(x, y, x + cornerRadius, y);
    renderCtx.closePath();
    
    // Floor surface
    renderCtx.fillStyle = room.color + '15';
    renderCtx.fill();
    
    // Outer glow for floor edge
    renderCtx.strokeStyle = wallColor;
    renderCtx.lineWidth = room.type === 'frantic' ? 2 : 1;
    renderCtx.shadowColor = wallColor;
    renderCtx.shadowBlur = room.type === 'frantic' ? 8 : 5;
    renderCtx.stroke();
    renderCtx.shadowBlur = 0;
}

function drawGoal(room, goal) {
    // Skip drawing if owner has shield active
    if (gameState.powerUps.playerEffects[goal.owner].shield > 0) {
        return;
    }
    
    const goalX = room.x + goal.x;
    const goalY = room.y + goal.y;
    const goalColor = gameState.playerColors[goal.owner];
    
    renderCtx.strokeStyle = goalColor;
    renderCtx.fillStyle = goalColor + '50';
    renderCtx.lineWidth = 4;
    renderCtx.shadowColor = goalColor;
    renderCtx.shadowBlur = 15;
    
    let drawX, drawY, drawWidth, drawHeight;
    
    switch (goal.direction) {
        case 'top':
            drawX = goalX - CONFIG.GOAL_SIZE/2;
            drawY = goalY - 8;
            drawWidth = CONFIG.GOAL_SIZE;
            drawHeight = 16;
            break;
        case 'right':
            drawX = goalX - 8;
            drawY = goalY - CONFIG.GOAL_SIZE/2;
            drawWidth = 16;
            drawHeight = CONFIG.GOAL_SIZE;
            break;
        case 'bottom':
            drawX = goalX - CONFIG.GOAL_SIZE/2;
            drawY = goalY - 8;
            drawWidth = CONFIG.GOAL_SIZE;
            drawHeight = 16;
            break;
        case 'left':
            drawX = goalX - 8;
            drawY = goalY - CONFIG.GOAL_SIZE/2;
            drawWidth = 16;
            drawHeight = CONFIG.GOAL_SIZE;
            break;
    }
    
    renderCtx.fillRect(drawX, drawY, drawWidth, drawHeight);
    renderCtx.strokeRect(drawX, drawY, drawWidth, drawHeight);
    
    renderCtx.fillStyle = '#ffffff';
    renderCtx.font = 'bold 14px Arial';
    renderCtx.textAlign = 'center';
    renderCtx.fillText(goal.owner, goalX, goalY + 5);
    
    renderCtx.shadowBlur = 0;
}

function drawTunnels() {
    Object.entries(rooms).forEach(([roomName, room]) => {
        Object.entries(room.connections || {}).forEach(([connectionName, tunnel]) => {
            const tunnelCenterX = room.x + tunnel.x;
            const tunnelCenterY = room.y + tunnel.y;
            const tunnelX = tunnelCenterX - tunnel.width/2;
            const tunnelY = tunnelCenterY - tunnel.height/2;
            
            draw3DPortal(tunnelCenterX, tunnelCenterY, tunnel.width, tunnel.height);
        });
    });
}

function draw3DPortal(centerX, centerY, width, height) {
    // Just draw the swirl effect - the wall opening is handled in wall rendering
    drawPortalSwirl(centerX, centerY, width, height);
}

function drawPortalSwirl(centerX, centerY, width, height) {
    // Deep space background
    renderCtx.save();
    const depthGradient = renderCtx.createRadialGradient(
        centerX, centerY, 0,
        centerX, centerY, Math.max(width, height) * 0.8
    );
    depthGradient.addColorStop(0, 'rgba(0, 30, 60, 0.9)');      // Deep blue center
    depthGradient.addColorStop(0.6, 'rgba(0, 15, 40, 0.7)');    // Darker
    depthGradient.addColorStop(1, 'rgba(0, 5, 20, 0.5)');       // Very dark edges
    
    renderCtx.fillStyle = depthGradient;
    renderCtx.fillRect(centerX - width, centerY - height, width * 2, height * 2);
    
    // Enhanced 3D swirl effect
    renderCtx.translate(centerX, centerY);
    
    // Multiple layered spirals for depth
    const spiralLayers = [
        { rotation: gameState.gameTime * 0.04, scale: 1.2, alpha: 0.8, color: 'rgba(0, 255, 255, ' },
        { rotation: gameState.gameTime * -0.03, scale: 0.8, alpha: 0.6, color: 'rgba(0, 200, 255, ' },
        { rotation: gameState.gameTime * 0.05, scale: 0.5, alpha: 0.9, color: 'rgba(100, 255, 255, ' }
    ];
    
    spiralLayers.forEach(layer => {
        renderCtx.save();
        renderCtx.rotate(layer.rotation);
        renderCtx.scale(layer.scale, layer.scale);
        
        // Animated spiral
        renderCtx.strokeStyle = layer.color + layer.alpha + ')';
        renderCtx.lineWidth = 2;
        renderCtx.beginPath();
        
        for (let i = 0; i < 30; i++) {
            const angle = i * 0.4;
            const radius = i * 2.5;
            const x = Math.cos(angle) * radius;
            const y = Math.sin(angle) * radius;
            
            if (i === 0) {
                renderCtx.moveTo(x, y);
            } else {
                renderCtx.lineTo(x, y);
            }
        }
        renderCtx.stroke();
        
        // Add spinning particles
        for (let i = 0; i < 10; i++) {
            const particleAngle = (gameState.gameTime * 0.02 + i * Math.PI * 2 / 10) * (layer.scale > 0.7 ? 1 : -1);
            const particleRadius = 20 + Math.sin(gameState.gameTime * 0.03 + i) * 8;
            const px = Math.cos(particleAngle) * particleRadius * layer.scale;
            const py = Math.sin(particleAngle) * particleRadius * layer.scale;
            
            renderCtx.beginPath();
            renderCtx.arc(px, py, 2 * layer.scale, 0, Math.PI * 2);
            renderCtx.fillStyle = layer.color + (layer.alpha * 0.9) + ')';
            renderCtx.fill();
        }
        
        renderCtx.restore();
    });
    
    renderCtx.restore();
}

function drawPowerUps() {
    gameState.powerUps.spawned.forEach(powerUp => {
        if (powerUp.room !== gameState.currentRoom) return;
        
        renderCtx.save();
        renderCtx.translate(powerUp.x, powerUp.y);
        renderCtx.rotate(powerUp.rotation);
        
        // Pulsing effect
        const pulseScale = 1 + Math.sin(powerUp.pulsePhase) * 0.2;
        renderCtx.scale(pulseScale, pulseScale);
        
        // Box background
        const size = CONFIG.POWERUP_SIZE;
        renderCtx.fillStyle = '#001144';
        renderCtx.strokeStyle = '#00ffff';
        renderCtx.lineWidth = 3;
        renderCtx.shadowColor = '#00ffff';
        renderCtx.shadowBlur = 15;
        
        // Draw box
        renderCtx.fillRect(-size, -size, size * 2, size * 2);
        renderCtx.strokeRect(-size, -size, size * 2, size * 2);
        
        // Draw icon based on type
        renderCtx.fillStyle = '#ffffff';
        renderCtx.font = 'bold 20px Arial';
        renderCtx.textAlign = 'center';
        renderCtx.textBaseline = 'middle';
        
        const icons = {
            magnet: 'üß≤',
            speed: '‚ö°',
            slowdown: 'üêå',
            shield: 'üõ°Ô∏è'
        };
        
        renderCtx.fillText(icons[powerUp.type] || '?', 0, 0);
        
        renderCtx.restore();
    });
}

function drawPuckTrail() {
    renderCtx.globalAlpha = 0.6;
    gameState.puck.trail.forEach((point, index) => {
        const alpha = index / gameState.puck.trail.length;
        const radius = CONFIG.PUCK_RADIUS * alpha * 0.7;
        
        renderCtx.fillStyle = `rgba(255, 255, 255, ${alpha * 0.5})`;
        renderCtx.beginPath();
        renderCtx.arc(point.x, point.y, radius, 0, Math.PI * 2);
        renderCtx.fill();
    });
    renderCtx.globalAlpha = 1;
}

function drawAllCharacters() {
    for (let playerId = 1; playerId <= 3; playerId++) {
        const playerColor = gameState.playerColors[playerId];
        
        for (let roomName in gameState.playerCharacters[playerId]) {
            const character = gameState.playerCharacters[playerId][roomName];
            drawCharacter(character, playerId, playerColor, character.active);
        }
    }
}

function drawCharacter(character, playerId, color, isActive) {
    const alpha = isActive ? 1.0 : 0.25;
    const isAI = gameState.playerTypes[playerId] === 'ai';
    const isKicking = character.kickEffect > 0;
    
    // No perspective scaling for players - they should be consistent size
    const perspectiveScale = 1.0;
    
    // Calculate tilt based on velocity
    const vx = character.vx || 0;
    const vy = character.vy || 0;
    const speed = Math.sqrt(vx * vx + vy * vy);
    const maxTilt = 0.4; // Maximum tilt amount (increased slightly)
    const tiltX = (vx / CONFIG.PLAYER_SPEED) * maxTilt;
    const tiltY = (vy / CONFIG.PLAYER_SPEED) * maxTilt;
    
    // Dynamic shadow based on movement direction and 3D height
    renderCtx.save();
    
    // Get character height (default 8px if not set)
    const characterHeight = character.z || 8;
    const heightFactor = characterHeight / 10; // Normalize to 0.8 for default height
    
    // Shadow opacity and size based on height
    renderCtx.globalAlpha = alpha * (0.4 + heightFactor * 0.3); // Higher = more opaque shadow
    renderCtx.fillStyle = 'rgba(0, 0, 0, 0.8)';
    
    // Shadow offset based on height (higher objects cast longer shadows)
    const baseShadowOffset = (6 + heightFactor * 4) * perspectiveScale;
    const shadowOffsetX = baseShadowOffset - tiltX * 20 * perspectiveScale;
    const shadowOffsetY = baseShadowOffset - tiltY * 20 * perspectiveScale;
    
    // Shadow size based on height (higher = larger shadow)
    const heightShadowScale = 0.8 + heightFactor * 0.4;
    const shadowScaleX = (1.1 + Math.abs(tiltY) * 0.2) * perspectiveScale * heightShadowScale;
    const shadowScaleY = (1.1 + Math.abs(tiltX) * 0.2) * perspectiveScale * heightShadowScale;
    
    renderCtx.translate(character.x + shadowOffsetX, character.y + shadowOffsetY);
    renderCtx.scale(shadowScaleX, shadowScaleY);
    renderCtx.beginPath();
    renderCtx.arc(0, 0, CONFIG.PADDLE_RADIUS * 0.9, 0, Math.PI * 2);
    renderCtx.fill();
    renderCtx.restore();
    
    // Draw subtle movement trail if moving fast
    if (isActive && (Math.abs(character.vx) > 2 || Math.abs(character.vy) > 2)) {
        const tailLength = 12;
        const tailSteps = 2;
        
        for (let i = 0; i < tailSteps; i++) {
            const t = (i + 1) / tailSteps;
            const tailX = character.x - character.vx * t * tailLength;
            const tailY = character.y - character.vy * t * tailLength;
            const tailRadius = CONFIG.PADDLE_RADIUS * (1 - t * 0.3);
            
            renderCtx.fillStyle = color;
            renderCtx.globalAlpha = alpha * 0.2 * (1 - t);
            renderCtx.beginPath();
            renderCtx.arc(tailX, tailY, tailRadius, 0, Math.PI * 2);
            renderCtx.fill();
        }
    }
    
    renderCtx.globalAlpha = alpha;
    
    // Enhanced visuals when kicking with perspective scaling
    const basePaddleRadius = isKicking ? CONFIG.PADDLE_RADIUS + 5 : CONFIG.PADDLE_RADIUS;
    const paddleRadius = basePaddleRadius * perspectiveScale;
    
    // Calculate subtle squash effect based on movement (speed already calculated above)
    const squashAmount = Math.min(speed / 20, 0.15); // Max 15% squash, more subtle
    
    renderCtx.fillStyle = color;
    renderCtx.strokeStyle = color;
    renderCtx.lineWidth = (isActive ? 4 : 2) * perspectiveScale;
    // Removed glow effect (shadowBlur) for cleaner look
    
    renderCtx.save();
    
    // Apply 3D height offset
    const playerHeightOffset = characterHeight * 0.3; // Visual height offset for players
    renderCtx.translate(character.x, character.y - playerHeightOffset);
    
    // Apply perspective scaling first
    renderCtx.scale(perspectiveScale, perspectiveScale);
    
    // Apply tilt and squash effect based on movement
    if (speed > 0.1) {
        // Apply 3D tilt effect
        const scaleX = 1 - Math.abs(tiltX) * 0.3;
        const scaleY = 1 - Math.abs(tiltY) * 0.3;
        const skewX = tiltX * 0.2;
        const skewY = tiltY * 0.2;
        
        // Create transformation matrix for tilted disk effect
        renderCtx.transform(scaleX, skewY, skewX, scaleY, 0, 0);
        
        // Add slight rotation based on movement direction
        const angle = Math.atan2(vy, vx);
        renderCtx.rotate(angle * 0.1);
    }
    
    // Draw the main character shape (using base radius since we already scaled)
    renderCtx.beginPath();
    renderCtx.arc(0, 0, basePaddleRadius, 0, Math.PI * 2);
    
    // Gradient fill for 3D effect
    const gradient = renderCtx.createRadialGradient(-paddleRadius * 0.3 * tiltX, -paddleRadius * 0.3 * tiltY, 0, 0, 0, paddleRadius);
    gradient.addColorStop(0, color);
    gradient.addColorStop(0.7, color);
    gradient.addColorStop(1, adjustBrightness(color, -30));
    renderCtx.fillStyle = gradient;
    renderCtx.fill();
    
    renderCtx.stroke();
    
    renderCtx.restore();
    
    // Draw power-up effects
    if (isActive) {
        const effects = gameState.powerUps.playerEffects[playerId];
        
        // Magnet effect
        if (effects.magnet > 0) {
            renderCtx.strokeStyle = '#ff00ff';
            renderCtx.lineWidth = 3;
            renderCtx.globalAlpha = 0.6 + Math.sin(gameState.gameTime * 0.08) * 0.3;
            renderCtx.beginPath();
            renderCtx.arc(character.x, character.y, 80, 0, Math.PI * 2);
            renderCtx.stroke();
            
            // Add inner ring for stronger visual
            renderCtx.lineWidth = 2;
            renderCtx.globalAlpha = 0.4 + Math.sin(gameState.gameTime * 0.12) * 0.2;
            renderCtx.beginPath();
            renderCtx.arc(character.x, character.y, 50, 0, Math.PI * 2);
            renderCtx.stroke();
            renderCtx.globalAlpha = 1;
        }
        
        // Speed effect
        if (effects.speed > 0) {
            renderCtx.strokeStyle = '#ffff00';
            renderCtx.lineWidth = 3;
            renderCtx.globalAlpha = 0.6;
            const sparkles = 3;
            for (let i = 0; i < sparkles; i++) {
                const angle = (gameState.gameTime * 0.1 + i * Math.PI * 2 / sparkles) % (Math.PI * 2);
                const x = character.x + Math.cos(angle) * 35;
                const y = character.y + Math.sin(angle) * 35;
                renderCtx.beginPath();
                renderCtx.moveTo(x - 5, y);
                renderCtx.lineTo(x + 5, y);
                renderCtx.moveTo(x, y - 5);
                renderCtx.lineTo(x, y + 5);
                renderCtx.stroke();
            }
            renderCtx.globalAlpha = 1;
        }
        
        // Shield effect
        if (effects.shield > 0) {
            renderCtx.strokeStyle = '#00ff00';
            renderCtx.fillStyle = 'rgba(0, 255, 0, 0.1)';
            renderCtx.lineWidth = 3;
            renderCtx.globalAlpha = 0.7 + Math.sin(gameState.gameTime * 0.05) * 0.3;
            renderCtx.beginPath();
            renderCtx.arc(character.x, character.y, CONFIG.PADDLE_RADIUS + 10, 0, Math.PI * 2);
            renderCtx.fill();
            renderCtx.stroke();
            renderCtx.globalAlpha = 1;
        }
    }
    
    // Player number removed for cleaner look
    
    // AI indicator
    if (isAI && isActive) {
        renderCtx.fillStyle = '#ffff00';
        renderCtx.font = '10px Arial';
        renderCtx.fillText('AI', character.x, character.y - CONFIG.PADDLE_RADIUS - 8);
    }
    
    // Kick indicator
    if (isActive && isKicking) {
        renderCtx.fillStyle = '#ffffff';
        renderCtx.font = 'bold 12px Arial';
        renderCtx.fillText('KICK!', character.x, character.y - CONFIG.PADDLE_RADIUS - 20);
    }
    
    // Can kick indicator (when close to puck)
    if (isActive && !isAI && gameState.kickCooldowns[playerId] === 0) {
        const dist = distance(character, gameState.puck);
        if (dist <= CONFIG.KICK_RANGE) {
            renderCtx.strokeStyle = '#ffff00';
            renderCtx.lineWidth = 2;
            renderCtx.setLineDash([3, 3]);
            renderCtx.beginPath();
            renderCtx.arc(character.x, character.y, CONFIG.KICK_RANGE, 0, Math.PI * 2);
            renderCtx.stroke();
            renderCtx.setLineDash([]);
        }
    }
    
    
    renderCtx.globalAlpha = 1;
}

function drawBounceEffects() {
    gameState.bounceEffects.forEach(effect => {
        const alpha = effect.life / effect.maxLife;
        const currentSize = effect.size * (1 - alpha * 0.5); // Shrink over time
        
        // Save context to avoid affecting other drawings
        renderCtx.save();
        
        renderCtx.globalAlpha = alpha * 0.8;
        renderCtx.strokeStyle = '#ffff00';
        renderCtx.lineWidth = 3;
        renderCtx.beginPath();
        renderCtx.arc(effect.x, effect.y, currentSize, 0, Math.PI * 2);
        renderCtx.stroke();
        
        // Inner ring
        renderCtx.strokeStyle = '#ffffff';
        renderCtx.lineWidth = 1;
        renderCtx.beginPath();
        renderCtx.arc(effect.x, effect.y, currentSize * 0.6, 0, Math.PI * 2);
        renderCtx.stroke();
        
        // Restore context
        renderCtx.restore();
    });
}

function drawPuck() {
    // Force reset all context state to ensure puck is visible
    renderCtx.save();
    
    // Get perspective scale for puck
    const perspectiveScale = getPerspectiveScale(gameState.puck.y, renderCtx.canvas.height);
    
    // Special effect during portal transition
    if (gameState.portalTransition.active) {
        const elapsed = Date.now() - gameState.portalTransition.startTime;
        const progress = elapsed / gameState.portalTransition.duration;
        
        // Fade out/in effect
        renderCtx.globalAlpha = progress < 0.5 ? 1 - (progress * 2) : (progress - 0.5) * 2;
        
        // Portal energy effect around puck (scaled with perspective)
        const baseEnergyRadius = 30 + Math.sin(elapsed * 0.01) * 10;
        const energyRadius = baseEnergyRadius * perspectiveScale;
        const gradient = renderCtx.createRadialGradient(gameState.puck.x, gameState.puck.y, 0, gameState.puck.x, gameState.puck.y, energyRadius);
        gradient.addColorStop(0, 'rgba(0, 255, 255, 0.8)');
        gradient.addColorStop(0.5, 'rgba(255, 255, 255, 0.4)');
        gradient.addColorStop(1, 'rgba(0, 255, 255, 0)');
        renderCtx.fillStyle = gradient;
        renderCtx.fillRect(gameState.puck.x - energyRadius, gameState.puck.y - energyRadius, energyRadius * 2, energyRadius * 2);
    } else {
        renderCtx.globalAlpha = 1.0;
    }
    
    renderCtx.shadowColor = 'transparent';
    renderCtx.shadowBlur = 0;
    
    // Puck shadow based on 3D height
    const puckHeight = gameState.puck.z || 0;
    const heightFactor = Math.max(0, puckHeight / 20); // Normalize height
    
    // Shadow gets larger and more offset when puck is higher
    const baseShadowOffset = (2 + heightFactor * 8) * perspectiveScale;
    const shadowRadius = CONFIG.PUCK_RADIUS * perspectiveScale * (1 + heightFactor * 0.5);
    const shadowOpacity = Math.max(0.2, 0.6 - heightFactor * 0.3); // Fade shadow when very high
    
    renderCtx.fillStyle = `rgba(0, 0, 0, ${shadowOpacity})`;
    renderCtx.beginPath();
    renderCtx.arc(gameState.puck.x + baseShadowOffset, gameState.puck.y + baseShadowOffset, shadowRadius, 0, Math.PI * 2);
    renderCtx.fill();
    
    // Main puck with rotation, perspective scaling, and 3D positioning
    const rotation = gameState.gameTime * 0.1;
    
    // Offset puck position based on height (pseudo-3D effect)
    const heightOffset = puckHeight * 0.5; // Visual height offset
    renderCtx.translate(gameState.puck.x, gameState.puck.y - heightOffset);
    renderCtx.scale(perspectiveScale, perspectiveScale);
    renderCtx.rotate(rotation);
    
    // Puck body - VERY bright and visible (using base radius since we already scaled)
    renderCtx.fillStyle = '#ffffff';
    renderCtx.strokeStyle = '#00ffff';
    renderCtx.lineWidth = 4;
    
    // Strong glow effect (scaled appropriately)
    renderCtx.shadowColor = '#ffffff';
    renderCtx.shadowBlur = 15;
    
    renderCtx.beginPath();
    renderCtx.arc(0, 0, CONFIG.PUCK_RADIUS, 0, Math.PI * 2);
    renderCtx.fill();
    
    // Reset shadow for stroke
    renderCtx.shadowColor = 'transparent';
    renderCtx.shadowBlur = 0;
    renderCtx.stroke();
    
    // Puck cross pattern - make it more visible
    renderCtx.strokeStyle = '#00dddd';
    renderCtx.lineWidth = 3;
    renderCtx.beginPath();
    renderCtx.moveTo(-CONFIG.PUCK_RADIUS * 0.7, 0);
    renderCtx.lineTo(CONFIG.PUCK_RADIUS * 0.7, 0);
    renderCtx.moveTo(0, -CONFIG.PUCK_RADIUS * 0.7);
    renderCtx.lineTo(0, CONFIG.PUCK_RADIUS * 0.7);
    renderCtx.stroke();
    
    // Restore context
    renderCtx.restore();
}
// ========== main.js ==========
let canvas, ctx;

// Initialize game
function init() {
    // Reset puck
    gameState.puck.x = 0;
    gameState.puck.y = 0;
    gameState.puck.vx = 0;
    gameState.puck.vy = 0;
    gameState.puck.currentRoom = 'center';
    gameState.puck.trail = [];
    
    // Initialize character positions
    initializeCharacterPositions();
    
    gameState.currentRoom = 'center';
    updateActiveCharacters();
    updateRoomIndicator();
    updatePuckDisplay();
    
    // Initialize AI
    initAI();
    
    // Start with face-off in center
    startFaceOff('center');
}

function initializeCharacterPositions() {
    const ROOM_SPACING = CONFIG.ROOM_SPACING;
    const ROOM_SIZE = CONFIG.ROOM_SIZE;
    
    // Reset character positions - adjusted for new room spacing (with Z-coordinates)
    gameState.playerCharacters[1].center = { x: -100, y: -100, z: 8, active: false, vx: 0, vy: 0 };
    gameState.playerCharacters[1].player1_zone = { x: 0, y: -ROOM_SIZE * ROOM_SPACING - 100, z: 8, active: false, vx: 0, vy: 0 };
    gameState.playerCharacters[1].player2_zone = { x: ROOM_SIZE * ROOM_SPACING + 100, y: -100, z: 8, active: false, vx: 0, vy: 0 };
    gameState.playerCharacters[1].player3_zone = { x: -ROOM_SIZE * ROOM_SPACING - 100, y: -100, z: 8, active: false, vx: 0, vy: 0 };
    gameState.playerCharacters[1].frantic_zone = { x: -100, y: ROOM_SIZE * ROOM_SPACING + 100, z: 8, active: false, vx: 0, vy: 0 };
    
    gameState.playerCharacters[2].center = { x: 0, y: 0, z: 8, active: false, vx: 0, vy: 0 };
    gameState.playerCharacters[2].player1_zone = { x: 0, y: -ROOM_SIZE * ROOM_SPACING, z: 8, active: false, vx: 0, vy: 0 };
    gameState.playerCharacters[2].player2_zone = { x: ROOM_SIZE * ROOM_SPACING, y: 0, z: 8, active: false, vx: 0, vy: 0 };
    gameState.playerCharacters[2].player3_zone = { x: -ROOM_SIZE * ROOM_SPACING, y: 0, z: 8, active: false, vx: 0, vy: 0 };
    gameState.playerCharacters[2].frantic_zone = { x: 0, y: ROOM_SIZE * ROOM_SPACING, z: 8, active: false, vx: 0, vy: 0 };
    
    gameState.playerCharacters[3].center = { x: 100, y: 100, z: 8, active: false, vx: 0, vy: 0 };
    gameState.playerCharacters[3].player1_zone = { x: 100, y: -ROOM_SIZE * ROOM_SPACING + 100, z: 8, active: false, vx: 0, vy: 0 };
    gameState.playerCharacters[3].player2_zone = { x: ROOM_SIZE * ROOM_SPACING - 100, y: 100, z: 8, active: false, vx: 0, vy: 0 };
    gameState.playerCharacters[3].player3_zone = { x: -ROOM_SIZE * ROOM_SPACING + 100, y: 100, z: 8, active: false, vx: 0, vy: 0 };
    gameState.playerCharacters[3].frantic_zone = { x: 100, y: ROOM_SIZE * ROOM_SPACING - 100, z: 8, active: false, vx: 0, vy: 0 };
}

// Update which characters are active based on puck location
function updateActiveCharacters() {
    const currentRoom = gameState.puck.currentRoom;
    
    // Deactivate all characters first
    for (let playerId = 1; playerId <= 3; playerId++) {
        for (let roomName in gameState.playerCharacters[playerId]) {
            gameState.playerCharacters[playerId][roomName].active = false;
        }
    }
    
    // Activate characters in the current room
    for (let playerId = 1; playerId <= 3; playerId++) {
        if (gameState.playerCharacters[playerId][currentRoom]) {
            gameState.playerCharacters[playerId][currentRoom].active = true;
        }
    }
    
    updateActivePlayerDisplay();
}

function updatePuckDisplay() {
    const puckX = Math.round(gameState.puck.x);
    const puckY = Math.round(gameState.puck.y);
    document.getElementById('puckPosition').textContent = `${puckX},${puckY}`;
}

function updateActivePlayerDisplay() {
    const currentRoom = gameState.puck.currentRoom;
    const roomNames = {
        center: 'Center',
        player1_zone: 'Player 1 Zone',
        player2_zone: 'Player 2 Zone', 
        player3_zone: 'Player 3 Zone',
        frantic_zone: 'FRANTIC ZONE!'
    };
    document.getElementById('activePlayers').textContent = roomNames[currentRoom] || currentRoom;
}

function updateRoomIndicator() {
    const roomNames = {
        center: 'Center',
        player1_zone: 'Player 1 Zone',
        player2_zone: 'Player 2 Zone', 
        player3_zone: 'Player 3 Zone',
        frantic_zone: 'FRANTIC ZONE!'
    };
    document.getElementById('currentRoom').textContent = roomNames[gameState.currentRoom] || gameState.currentRoom;
}

function updateScoreDisplay() {
    document.getElementById('score1').textContent = gameState.playerScores[1];
    document.getElementById('score2').textContent = gameState.playerScores[2];
    document.getElementById('score3').textContent = gameState.playerScores[3];
}

// Update game logic
function update() {
    if (!gameState.gameStarted || gameState.isPaused) return;
    
    gameState.gameTime++;
    
    // Update face-off if active
    updateFaceOff();
    
    // Update cooldowns and effects
    updateCooldowns();
    updateBounceEffects();
    
    // Update portal transition
    updatePortalTransition();
    
    // Update power-ups
    spawnPowerUp();
    updatePowerUps();
    updatePowerUpDisplay();
    
    // Move characters (human input + AI) - skip during face-off
    if (!gameState.faceOff.active) {
        const baseSpeed = CONFIG.PLAYER_SPEED;
        
        // Update each player
        for (let playerId = 1; playerId <= 3; playerId++) {
            if (gameState.playerTypes[playerId] === 'human') {
                updateHumanPlayer(playerId, baseSpeed);
            } else {
                updateAI(playerId);
            }
        }
    }
    
    // Update puck physics (skip during portal transition or face-off)
    if (!gameState.portalTransition.active && !gameState.faceOff.active) {
        updatePuck();
        if (checkPuckStuck()) {
            startFaceOff(gameState.puck.currentRoom);
        }
    }
    
    // Update camera
    const targetCameraX = gameState.puck.x - canvas.width / 2;
    const targetCameraY = gameState.puck.y - canvas.height / 2;
    gameState.camera.x += (targetCameraX - gameState.camera.x) * 0.08;
    gameState.camera.y += (targetCameraY - gameState.camera.y) * 0.08;
    
    // Update puck position display
    updatePuckDisplay();
    
    // Check for goals
    checkGoals();
}

function updateHumanPlayer(playerId, baseSpeed) {
    for (let roomName in gameState.playerCharacters[playerId]) {
        const character = gameState.playerCharacters[playerId][roomName];
        if (!character.active) continue;
        
        const { moveX, moveY } = updatePlayerMovement(playerId, gameState.keys);
        
        // Initialize momentum if not exists
        if (character.momentum === undefined) {
            character.momentum = { x: 0, y: 0 };
        }
        
        const speedBoost = gameState.powerUps.playerEffects[playerId].speed > 0 ? 1.5 : 1;
        const slowdownFactor = gameState.powerUps.playerEffects[playerId].slowdown > 0 ? 0.5 : 1;
        const speed = baseSpeed * speedBoost * slowdownFactor;
        
        // Apply acceleration to momentum
        const acceleration = 0.3; // How quickly player accelerates
        const friction = 0.85; // How quickly player slows down
        
        if (moveX !== 0 || moveY !== 0) {
            // Normalize diagonal movement
            const length = Math.sqrt(moveX * moveX + moveY * moveY);
            const targetVx = (moveX / length) * speed;
            const targetVy = (moveY / length) * speed;
            
            // Accelerate toward target velocity
            character.momentum.x += (targetVx - character.momentum.x) * acceleration;
            character.momentum.y += (targetVy - character.momentum.y) * acceleration;
        } else {
            // Apply friction when not moving
            character.momentum.x *= friction;
            character.momentum.y *= friction;
        }
        
        // Apply momentum to position
        character.x += character.momentum.x;
        character.y += character.momentum.y;
        
        // Update visual velocity
        character.vx = character.momentum.x * 0.8;
        character.vy = character.momentum.y * 0.8;
        
        constrainCharacterToRoom(character, roomName);
    }
}

// Menu system
function initMenu() {
    const humanButtons = document.querySelectorAll('[data-humans]');
    const difficultyButtons = document.querySelectorAll('[data-difficulty]');
    const startButton = document.getElementById('startButton');
    
    humanButtons.forEach(btn => {
        btn.addEventListener('click', () => {
            humanButtons.forEach(b => b.classList.remove('selected'));
            btn.classList.add('selected');
            gameState.humanPlayers = parseInt(btn.dataset.humans);
            gameState.aiPlayers = 3 - gameState.humanPlayers;
            updatePlayerTypes();
        });
    });
    
    difficultyButtons.forEach(btn => {
        btn.addEventListener('click', () => {
            difficultyButtons.forEach(b => b.classList.remove('selected'));
            btn.classList.add('selected');
            gameState.aiDifficulty = btn.dataset.difficulty;
            const displayNames = { easy: 'Dum', medium: 'Meh', hard: 'Genial' };
            document.getElementById('difficultyDisplay').textContent = displayNames[gameState.aiDifficulty];
        });
    });
    
    startButton.addEventListener('click', startGame);
}

function updatePlayerTypes() {
    for (let i = 1; i <= 3; i++) {
        gameState.playerTypes[i] = i <= gameState.humanPlayers ? 'human' : 'ai';
        const aiIndicator = document.getElementById(`ai${i}`);
        aiIndicator.textContent = gameState.playerTypes[i] === 'ai' ? '(AI)' : '';
    }
}

function startGame() {
    gameState.gameStarted = true;
    document.getElementById('startMenu').style.display = 'none';
    updatePlayerTypes();
    init();
}

function showMenu() {
    gameState.gameStarted = false;
    document.getElementById('startMenu').style.display = 'flex';
}

// Game loop
function gameLoop() {
    update();
    render();
    requestAnimationFrame(gameLoop);
}

// Initialize everything
window.addEventListener('DOMContentLoaded', () => {
    const canvasData = initCanvas();
    canvas = canvasData.canvas;
    ctx = canvasData.ctx;
    
    initMenu();
    initInput();
    updatePlayerTypes();
    gameLoop();
});

// Export functions needed by other modules
window.initGame = init;
window.showGameMenu = showMenu;
window.updateActiveCharacters = updateActiveCharacters;
window.updateRoomIndicator = updateRoomIndicator;
window.updateScoreDisplay = updateScoreDisplay;
window.createBounceEffect = createBounceEffect;
window.startFaceOff = startFaceOff;
window.tryKick = tryKick;
</script>
</body>
</html>